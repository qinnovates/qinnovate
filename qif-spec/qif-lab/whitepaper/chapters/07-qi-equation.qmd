---
title: "The QI Equation: Two Complementary Views"
---

```{python}
#| label: setup
#| include: false
import sys, os
sys.path.insert(0, '/Users/mac/Documents/PROJECTS/qinnovates/mindloft/drafts/ai-working/qif-lab')
import numpy as np
import pandas as pd
from src.config import DECOHERENCE_CAMPS, DEFAULT_C1_PARAMS
from src.qif_equations import (
    qi_candidate1, qi_candidate2, quantum_gate,
    von_neumann_entropy, QICandidate1Params,
    sensitivity_analysis_c1, sensitivity_heatmap_c1
)

# Plotly / matplotlib detection
_IS_HTML = os.environ.get('QUARTO_FIG_FORMAT', 'png') != 'pdf'
try:
    import plotly.graph_objects as go
    _HAS_PLOTLY = True
except ImportError:
    _HAS_PLOTLY = False
_USE_PLOTLY = _IS_HTML and _HAS_PLOTLY

if _USE_PLOTLY:
    _plotly_template = go.layout.Template(
        layout=go.Layout(
            paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='#161b22',
            font=dict(color='#c9d1d9', family='sans-serif', size=12),
            xaxis=dict(gridcolor='#21262d', linecolor='#30363d', tickfont=dict(color='#8b949e')),
            yaxis=dict(gridcolor='#21262d', linecolor='#30363d', tickfont=dict(color='#8b949e')),
            colorway=['#58a6ff', '#bc8cff', '#3fb950', '#f85149', '#d29922', '#79c0ff', '#f0883e'],
        )
    )

COLORS = {
    'classical': '#58a6ff', 'quantum': '#bc8cff', 'neural': '#3fb950',
    'danger': '#f85149', 'warning': '#d29922', 'accent': '#79c0ff', 'highlight': '#f0883e',
}

import matplotlib.pyplot as plt
plt.rcParams.update({
    'figure.facecolor': '#0d1117', 'axes.facecolor': '#161b22',
    'text.color': '#c9d1d9', 'axes.labelcolor': '#c9d1d9',
    'xtick.color': '#8b949e', 'ytick.color': '#8b949e',
    'axes.edgecolor': '#30363d', 'grid.color': '#21262d',
})
```

## Why Two Equations?

The QI equation is presented in two complementary forms:

- **Candidate 1 (Additive/Engineering):** Modular, intuitive, each term independently computable. For BCI engineers building real systems.
- **Candidate 2 (Tensor/Theoretical):** Mathematically rigorous, entanglement natural, decoherence emergent. For physicists evaluating the framework.

Both produce compatible security assessments. They are two lenses on the same reality.

## Candidate 1: The Engineering Equation

$$QI(t) = \alpha \cdot C_{class} + \beta \cdot (1 - \Gamma_D(t)) \cdot [Q_i + \delta \cdot Q_{entangle}] - \gamma \cdot Q_{tunnel}$$

where $\Gamma_D(t) = 1 - e^{-t/\tau_D}$

```{python}
#| label: fig-qi-decoherence
#| fig-cap: "QI score over time: quantum terms fade as decoherence progresses. The shaded region shows the quantum contribution — it's strongest when t << τ_D and vanishes as the system decoheres."

tau_d = DEFAULT_C1_PARAMS['tau_d']
times = np.logspace(-8, -2, 200)

total_scores = []
classical_scores = []

for t in times:
    params = QICandidate1Params(tau_d=tau_d)
    total = qi_candidate1(c_class=0.8, qi_indeterminacy=0.5, q_entangle=0.3, q_tunnel=0.1, t=t, params=params)
    params_c = QICandidate1Params(tau_d=1e-15)
    classical = qi_candidate1(c_class=0.8, qi_indeterminacy=0.5, q_entangle=0.3, q_tunnel=0.1, t=t, params=params_c)
    total_scores.append(total)
    classical_scores.append(classical)

if _USE_PLOTLY:
    fig = go.Figure()
    # Fill between classical and total
    fig.add_trace(go.Scatter(
        x=times.tolist() + times[::-1].tolist(),
        y=total_scores + classical_scores[::-1],
        fill='toself', fillcolor='rgba(155, 89, 182, 0.2)', line=dict(width=0),
        name='Quantum contribution', hoverinfo='skip'))
    fig.add_trace(go.Scatter(x=times.tolist(), y=total_scores, mode='lines',
                             line=dict(color='#9b59b6', width=2.5), name='QI(t) total',
                             hovertemplate='t=%{x:.2e} s<br>QI=%{y:.4f}<extra>Total</extra>'))
    fig.add_trace(go.Scatter(x=times.tolist(), y=classical_scores, mode='lines',
                             line=dict(color='#3498db', width=2, dash='dash'), name='Classical only',
                             hovertemplate='t=%{x:.2e} s<br>QI=%{y:.4f}<extra>Classical</extra>'))
    for camp in DECOHERENCE_CAMPS:
        fig.add_vline(x=camp['tau_d'], line_dash='dot', line_color='gray', opacity=0.5)
        fig.add_annotation(x=np.log10(camp['tau_d']), y=max(total_scores)*0.95,
                           text=camp['camp'].split('(')[0].strip(),
                           textangle=-90, font=dict(size=8, color='#8b949e'),
                           showarrow=False, xref='x', yref='y')
    fig.update_xaxes(type='log', title='Time (seconds)')
    fig.update_yaxes(title='QI Score')
    fig.update_layout(template=_plotly_template, title='QI Equation: Quantum Terms Fade with Decoherence',
                      height=500)
    fig.show()
else:
    fig, ax = plt.subplots(figsize=(10, 6))
    ax.fill_between(times, classical_scores, total_scores, alpha=0.3, color='#9b59b6', label='Quantum contribution')
    ax.plot(times, total_scores, color='#9b59b6', linewidth=2.5, label='QI(t) total')
    ax.plot(times, classical_scores, color='#3498db', linewidth=2, linestyle='--', label='Classical only')
    for camp in DECOHERENCE_CAMPS:
        ax.axvline(x=camp['tau_d'], color='gray', linestyle=':', alpha=0.5)
        ax.text(camp['tau_d'], max(total_scores)*0.95, camp['camp'].split('(')[0].strip(),
                ha='center', va='top', fontsize=8, rotation=90, alpha=0.7)
    ax.set_xscale('log'); ax.set_xlabel('Time (seconds)'); ax.set_ylabel('QI Score')
    ax.set_title('QI Equation: Quantum Terms Fade with Decoherence')
    ax.legend(loc='center right'); plt.tight_layout(); plt.show()
```

### Live Computation Demo

Change any input and the QI score updates:

```{python}
#| label: tbl-qi-demo
#| tbl-cap: "QI Equation Output Across Decoherence Timescales"

results = []
for camp in DECOHERENCE_CAMPS:
    params = QICandidate1Params(tau_d=camp['tau_d'])
    gate = quantum_gate(1e-6, camp['tau_d'])
    qi_score = qi_candidate1(
        c_class=0.8, qi_indeterminacy=0.5, q_entangle=0.3, q_tunnel=0.1,
        t=1e-6, params=params
    )
    results.append({
        'Camp': camp['camp'],
        'τ_D': camp['label'],
        'Quantum Gate': f'{gate:.4f}',
        'QI Score': f'{qi_score:.4f}',
    })

pd.DataFrame(results)
```

## Candidate 2: The Theoretical Equation

$$QI = C_{class} \otimes e^{-S_{quantum}}$$

where $S_{quantum} = S_{vN}(\rho(t)) + \lambda \cdot \Phi_{tunnel} - \mu \cdot E(\rho_{AB})$

The security metric is: $S_{QI} = \text{Tr}(\hat{QI} \cdot \rho_{total})$

## Comparing the Two Candidates

```{python}
#| label: tbl-comparison
#| tbl-cap: "Candidate Comparison"

comparison = [
    ["Audience", "BCI engineers", "Physicists, theorists"],
    ["Structure", "Sum of terms", "Tensor product"],
    ["Decoherence", "Explicit gate ΓD(t)", "Emerges from SvN(ρ(t))"],
    ["Entanglement", "Added term (δ·Qentangle)", "Natural via E(ρAB)"],
    ["Calibration params", "4 (α, β, γ, δ)", "2 (λ, μ)"],
    ["Measurability", "Each term independent", "Requires state tomography"],
    ["Computational cost", "Low", "High"],
    ["Intuition", "High", "Low (requires QM background)"],
]

pd.DataFrame(comparison, columns=["Property", "Candidate 1 (Additive)", "Candidate 2 (Tensor)"])
```

## Sensitivity Analysis {#sec-sensitivity}

Which parameters drive the QI score most? A one-at-a-time sensitivity analysis sweeps each parameter ±50% from baseline while holding all others constant.

```{python}
#| label: fig-tornado
#| fig-cap: "Tornado plot: sensitivity of QI score to ±50% parameter variation. Longer bars indicate parameters that most strongly influence the security assessment."

sa = sensitivity_analysis_c1()

# Sort by total range (most sensitive first)
ranges = [abs(h - l) for h, l in zip(sa['high'], sa['low'])]
sorted_idx = np.argsort(ranges)

param_labels = {
    'c_class': 'C\u0302_class (classical)', 'qi_indeterminacy': 'Q\u0302_i (indeterminacy)',
    'q_entangle': 'Q\u0302_entangle', 'q_tunnel': 'Q\u0302_tunnel',
    'alpha': '\u03b1 (classical wt)', 'beta': '\u03b2 (quantum wt)',
    'gamma': '\u03b3 (tunnel wt)', 'delta': '\u03b4 (entangle wt)', 'tau_d': '\u03c4_D (decoherence)',
}

if _USE_PLOTLY:
    fig = go.Figure()
    for i, idx in enumerate(sorted_idx):
        param = sa['params'][idx]
        low_val = sa['low'][idx]
        high_val = sa['high'][idx]
        label = param_labels.get(param, param)

        fig.add_trace(go.Bar(
            y=[label], x=[high_val - sa['baseline']], base=[sa['baseline']],
            orientation='h', marker_color='#3fb950', opacity=0.7, name='+50%' if i == 0 else None,
            showlegend=(i == 0),
            hovertemplate=f'{label}<br>+50%: {high_val:.4f}<extra></extra>'))
        fig.add_trace(go.Bar(
            y=[label], x=[low_val - sa['baseline']], base=[sa['baseline']],
            orientation='h', marker_color='#f85149', opacity=0.7, name='-50%' if i == 0 else None,
            showlegend=(i == 0),
            hovertemplate=f'{label}<br>-50%: {low_val:.4f}<extra></extra>'))

    fig.add_vline(x=sa['baseline'], line_color='white', line_width=1.5)
    fig.update_layout(template=_plotly_template, barmode='overlay',
                      title=f'Parameter Sensitivity (baseline QI = {sa["baseline"]:.3f})',
                      xaxis_title='QI Score', height=500)
    fig.show()
else:
    fig, ax = plt.subplots(figsize=(10, 6))
    y_pos = np.arange(len(sorted_idx))
    for i, idx in enumerate(sorted_idx):
        param = sa['params'][idx]
        low_val = sa['low'][idx]
        high_val = sa['high'][idx]
        ax.barh(i, high_val - sa['baseline'], left=sa['baseline'],
                color='#3fb950', alpha=0.7, height=0.6)
        ax.barh(i, low_val - sa['baseline'], left=sa['baseline'],
                color='#f85149', alpha=0.7, height=0.6)
    ax.axvline(x=sa['baseline'], color='white', linewidth=1.5, linestyle='-')
    ax.set_yticks(y_pos)
    ax.set_yticklabels([param_labels.get(sa['params'][i], sa['params'][i]) for i in sorted_idx])
    ax.set_xlabel('QI Score')
    ax.set_title(f'Parameter Sensitivity (baseline QI = {sa["baseline"]:.3f})')
    ax.legend(['Baseline', '+50%', '-50%'], loc='lower right')
    plt.tight_layout(); plt.show()
```

### Decoherence Time vs Elapsed Time

The core physics question — does quantum protection survive long enough to matter? This heatmap shows QI as a function of both τ_D (decoherence time) and t (elapsed time since state preparation).

```{python}
#| label: fig-heatmap-tau-t
#| fig-cap: "Heatmap: QI score as a function of decoherence time (τ_D) and elapsed time (t). The diagonal where t ≈ τ_D marks the transition from quantum-protected (upper-left) to classical (lower-right)."

hm = sensitivity_heatmap_c1(
    param_x='tau_d', param_y='t',
    x_range=(1e-15, 1e0),
    y_range=(1e-9, 1e-3),
    n_points=80,
)

if _USE_PLOTLY:
    fig = go.Figure()
    fig.add_trace(go.Heatmap(
        x=hm['x_vals'].tolist() if hasattr(hm['x_vals'], 'tolist') else hm['x_vals'],
        y=hm['y_vals'].tolist() if hasattr(hm['y_vals'], 'tolist') else hm['y_vals'],
        z=hm['qi_grid'].tolist() if hasattr(hm['qi_grid'], 'tolist') else hm['qi_grid'],
        colorscale='Viridis', colorbar=dict(title='QI Score'),
        hovertemplate='τ_D=%{x:.2e}<br>t=%{y:.2e}<br>QI=%{z:.4f}<extra></extra>'))
    # t = tau_d diagonal
    diag = np.logspace(-15, 0, 100)
    fig.add_trace(go.Scatter(x=diag.tolist(), y=diag.tolist(), mode='lines',
                             line=dict(color='white', dash='dash', width=1), name='t = τ_D'))
    fig.update_xaxes(type='log', title='Decoherence time τ_D (seconds)')
    fig.update_yaxes(type='log', title='Elapsed time t (seconds)')
    fig.update_layout(template=_plotly_template, title='QI Score: τ_D vs t', height=600)
    fig.show()
else:
    fig, ax = plt.subplots(figsize=(10, 7))
    im = ax.pcolormesh(hm['x_vals'], hm['y_vals'], hm['qi_grid'], cmap='viridis', shading='auto')
    ax.set_xscale('log'); ax.set_yscale('log')
    ax.set_xlabel('Decoherence time τ_D (seconds)'); ax.set_ylabel('Elapsed time t (seconds)')
    ax.set_title('QI Score: τ_D vs t')
    fig.colorbar(im, ax=ax, label='QI Score')
    diag = np.logspace(-15, 0, 100)
    ax.plot(diag, diag, 'w--', alpha=0.5, linewidth=1, label='t = τ_D')
    ax.legend(loc='upper left'); plt.tight_layout(); plt.show()
```

### Classical vs Quantum Weight Trade-off

```{python}
#| label: fig-heatmap-alpha-beta
#| fig-cap: "Heatmap: QI score as α (classical weight) and β (quantum weight) vary. The balance between classical and quantum contributions determines overall security posture."

hm2 = sensitivity_heatmap_c1(
    param_x='alpha', param_y='beta',
    x_range=(0.1, 2.0),
    y_range=(0.1, 2.0),
    n_points=60,
)

if _USE_PLOTLY:
    fig = go.Figure()
    fig.add_trace(go.Heatmap(
        x=hm2['x_vals'].tolist() if hasattr(hm2['x_vals'], 'tolist') else hm2['x_vals'],
        y=hm2['y_vals'].tolist() if hasattr(hm2['y_vals'], 'tolist') else hm2['y_vals'],
        z=hm2['qi_grid'].tolist() if hasattr(hm2['qi_grid'], 'tolist') else hm2['qi_grid'],
        colorscale='Viridis', colorbar=dict(title='QI Score'),
        hovertemplate='α=%{x:.2f}<br>β=%{y:.2f}<br>QI=%{z:.4f}<extra></extra>'))
    fig.add_trace(go.Scatter(x=[1.0], y=[1.0], mode='markers',
                             marker=dict(symbol='star', size=15, color='white'), name='Default (1.0, 1.0)'))
    fig.update_xaxes(title='α (classical weight)')
    fig.update_yaxes(title='β (quantum weight)')
    fig.update_layout(template=_plotly_template, title='QI Score: α vs β', height=600)
    fig.show()
else:
    fig, ax = plt.subplots(figsize=(8, 7))
    im = ax.pcolormesh(hm2['x_vals'], hm2['y_vals'], hm2['qi_grid'], cmap='viridis', shading='auto')
    ax.set_xlabel('α (classical weight)'); ax.set_ylabel('β (quantum weight)')
    ax.set_title('QI Score: α vs β')
    fig.colorbar(im, ax=ax, label='QI Score')
    ax.plot([1.0], [1.0], 'w*', markersize=15, label='Default (1.0, 1.0)')
    ax.legend(); plt.tight_layout(); plt.show()
```

::: {.callout-important title="Key Finding"}
The QI score is most sensitive to **Ĉ_class** (the classical coherence metric) and **α** (its weight), confirming that classical signal integrity is the foundation of the framework. The quantum terms provide additional security margin when decoherence times are favorable, but the classical baseline dominates. **Experimental priority: determine τ_D in vivo** — this single measurement would most dramatically narrow the framework's uncertainty.
:::
