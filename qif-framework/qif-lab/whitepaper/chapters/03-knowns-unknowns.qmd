---
title: "What We Know and What We Don't"
---

> *For every known, the math gives the same answer every time. For every unknown, QIF assigns a variable — so when science fills in the value, the equation already works.*

```{python}
#| label: setup
#| include: false
import sys, os
sys.path.insert(0, '/Users/mac/Documents/PROJECTS/qinnovates/mindloft/drafts/ai-working/qif-lab')
from src.config import FREQUENCY_BANDS, NEURO_CONSTANTS, QUANTUM_THREATS, DECOHERENCE_CAMPS
import pandas as pd
```

## The Knowns: Established Science QIF Builds On

These 21 equations and facts form the foundation of QIF. Every one is established science — peer-reviewed, experimentally validated, and universally accepted.

```{python}
#| label: tbl-knowns
#| tbl-cap: "Established Science Used in QIF"

knowns = [
    ["Signals have timing jitter", "Phase variance σ²ᵩ", "Coherence metric (Cₛ)", "Established"],
    ["Signals degrade over pathways", "Transport variance σ²τ", "Coherence metric (Cₛ)", "Established"],
    ["Amplitude fluctuates", "Gain variance σ²ᵧ", "Coherence metric (Cₛ)", "Established"],
    ["Ion channels have voltage gates", "Hodgkin-Huxley (1952)", "Classical BCI security", "Established"],
    ["Ions have equilibrium potentials", "Nernst (1889)", "Tissue modeling", "Established"],
    ["Ion flux depends on gradients", "Nernst-Planck", "Interface physics", "Established"],
    ["Channels have bandwidth limits", "Shannon capacity (1948)", "Signal integrity", "Established"],
    ["Thermal noise follows statistics", "Boltzmann distribution", "Noise modeling", "Established"],
    ["Signals decompose into frequencies", "Fourier transform", "Oscillatory analysis", "Established"],
    ["Tissue has frequency-dependent impedance", "Cole-Cole dispersion", "Electrode modeling", "Established"],
    ["Electric fields in tissue follow Poisson", "Quasi-static Poisson", "Volume conduction", "Established"],
    ["Particles tunnel through barriers", "T ≈ e^(−2κd)", "Vulnerability + biometric", "Established"],
    ["Quantum states can't be copied", "No-cloning theorem (1982)", "Anti-spoofing", "Established"],
    ["Measurement disturbs quantum states", "Heisenberg uncertainty (1927)", "Eavesdrop detection", "Established"],
    ["Generalized uncertainty has exact form", "Robertson-Schrödinger (1929)", "Indeterminacy computation", "Established"],
    ["Quantum probability from wave function", "Born rule (1926)", "State measurement", "Established"],
    ["Mixed state uncertainty is quantifiable", "Von Neumann entropy (1932)", "Quantum security scoring", "Established"],
    ["Entangled pairs are correlated", "Bell states (1964)", "QKD security", "Established"],
    ["Frequent measurement freezes evolution", "Quantum Zeno effect (1977)", "Zeno-BCI hypothesis", "Established"],
    ["Quantum factoring is efficient", "Shor's algorithm O(n³) (1994)", "Crypto threat", "Established"],
    ["Quantum search is optimal", "Grover's algorithm O(√N) (1996)", "Crypto threat", "Established"],
]

df = pd.DataFrame(knowns, columns=["Known Fact", "Equation/Principle", "QIF Uses It For", "Status"])
df
```

## The Unknowns: Where QIF Fills the Gap

These 8 open questions are where QIF makes its contribution. Rather than guessing the answers, QIF assigns each unknown a mathematical variable — the equation works regardless.

```{python}
#| label: tbl-unknowns
#| tbl-cap: "Open Questions Modeled as QIF Variables"

unknowns = [
    ["Decoherence time in neural tissue", "10⁻¹³ s vs 10⁻⁵ s vs hours (8 OOM disagreement)", "Tunable parameter", "τ_D"],
    ["Does the brain use entanglement?", "Fisher's Posner molecules — unverified", "Model both biological + artificial", "Qentangle"],
    ["Quantum indeterminacy at BCI interface", "No one has quantified it", "Central QI variable", "Qi"],
    ["Ion channel tunneling uniqueness", "Are profiles unique per person?", "Quantum biometric hypothesis", "Qtunnel (biometric)"],
    ["Does BCI sampling stabilize quantum states?", "Zeno-BCI — never tested", "Modeled hypothesis", "Zeno term"],
    ["Davydov soliton vulnerability", "Can THz radiation trigger false synaptic events?", "Tunneling vulnerability model", "Qtunnel (threat)"],
    ["Silicon-tissue quantum boundary", "No quantum-level framework exists", "I0 Neural Interface", "QIF Band I0"],
    ["Classical-quantum transition shape", "Binary or continuous?", "Continuous dial: ΓD(t) = 1 − e^(−t/τ_D)", "ΓD(t)"],
]

df = pd.DataFrame(unknowns, columns=["Unknown", "The Mystery", "QIF's Approach", "Variable"])
df
```

## The QIF Bridge

```{python}
#| label: fig-bridge
#| fig-cap: "QIF bridges established science and open questions. Knowns enter as constants, unknowns as variables. The equation works regardless of which unknowns get resolved."

import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import numpy as np

fig, ax = plt.subplots(figsize=(12, 6))

# Knowns (left)
for i in range(7):
    y = 5 - i * 0.8
    rect = plt.Rectangle((0, y), 2.5, 0.65, facecolor='#3498db', alpha=0.8, edgecolor='white', linewidth=1.5)
    ax.add_patch(rect)

ax.text(1.25, 5.8, 'KNOWNS\n(21 established equations)', ha='center', fontweight='bold', fontsize=11, color='#3498db')

# Unknowns (right)
for i in range(7):
    y = 5 - i * 0.8
    rect = plt.Rectangle((9.5, y), 2.5, 0.65, facecolor='#e74c3c', alpha=0.6, edgecolor='#e74c3c',
                          linewidth=1.5, linestyle='--')
    ax.add_patch(rect)

ax.text(10.75, 5.8, 'UNKNOWNS\n(8 open questions)', ha='center', fontweight='bold', fontsize=11, color='#e74c3c')

# QI Equation (center)
center_rect = plt.Rectangle((4, 1.5), 4, 3.5, facecolor='#9b59b6', alpha=0.15,
                              edgecolor='#9b59b6', linewidth=3, zorder=2)
ax.add_patch(center_rect)
ax.text(6, 3.8, 'QI EQUATION', ha='center', fontweight='bold', fontsize=14, color='#9b59b6')
ax.text(6, 3.1, 'QI(t) = α·Cclass +\nβ·(1−ΓD)·[Qi + δ·Qentangle]\n− γ·Qtunnel',
        ha='center', fontsize=9, color='#9b59b6', family='monospace')

# Arrows
for i in range(5):
    y = 4.6 - i * 0.8
    ax.annotate('', xy=(4, y + 0.3), xytext=(2.5, y + 0.3),
                arrowprops=dict(arrowstyle='->', color='#3498db', lw=1.5))
for i in range(5):
    y = 4.6 - i * 0.8
    ax.annotate('', xy=(8, y + 0.3), xytext=(9.5, y + 0.3),
                arrowprops=dict(arrowstyle='<-', color='#e74c3c', lw=1.5, linestyle='--'))

ax.text(3.2, 0.8, 'Constants\n(fixed values)', ha='center', fontsize=9, color='#3498db')
ax.text(8.8, 0.8, 'Variables\n(tunable parameters)', ha='center', fontsize=9, color='#e74c3c')

ax.set_xlim(-0.5, 12.5)
ax.set_ylim(0, 6.5)
ax.axis('off')

plt.tight_layout()
plt.show()
```
