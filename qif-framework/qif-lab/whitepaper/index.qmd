---
title: "QIF — Quantum Indeterministic Framework for Neural Security"
subtitle: "Why the Next Generation of Brain-Computer Interfaces Needs Quantum-Aware Protection"
author: "Kevin Qi, with Claude (Anthropic)"
date: "2026-02-02"
format:
  html:
    theme: darkly
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: true
    code-tools: true
    self-contained: true
bibliography: references.bib
csl: https://www.zotero.org/styles/ieee
---

```{python}
#| label: setup
#| include: false
import sys
sys.path.insert(0, '..')
from src.config import *
from src.qif_equations import *
from src.synthetic_data import generate_custom_signals, SCENARIOS
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches

# Detect output format: Plotly for HTML, matplotlib for PDF
import os as _os
_IS_HTML = _os.environ.get('QUARTO_FIG_FORMAT', 'png') != 'pdf'
try:
    import plotly.graph_objects as go
    import plotly.express as px
    _HAS_PLOTLY = True
except ImportError:
    _HAS_PLOTLY = False
_USE_PLOTLY = _IS_HTML and _HAS_PLOTLY

# Plotly dark template
if _USE_PLOTLY:
    import plotly.io as pio
    _plotly_template = go.layout.Template(
        layout=go.Layout(
            paper_bgcolor='rgba(0,0,0,0)',
            plot_bgcolor='#161b22',
            font=dict(color='#c9d1d9', family='sans-serif', size=12),
            xaxis=dict(gridcolor='#21262d', linecolor='#30363d', tickfont=dict(color='#8b949e')),
            yaxis=dict(gridcolor='#21262d', linecolor='#30363d', tickfont=dict(color='#8b949e')),
            colorway=['#58a6ff', '#bc8cff', '#3fb950', '#f85149', '#d29922', '#79c0ff', '#f0883e'],
        )
    )

# Dark theme for matplotlib (PDF fallback)
plt.rcParams.update({
    'figure.facecolor': '#0d1117',
    'axes.facecolor': '#161b22',
    'text.color': '#c9d1d9',
    'axes.labelcolor': '#c9d1d9',
    'xtick.color': '#8b949e',
    'ytick.color': '#8b949e',
    'axes.edgecolor': '#30363d',
    'grid.color': '#21262d',
    'font.family': 'sans-serif',
    'font.size': 11,
})
COLORS = {
    'classical': '#58a6ff', 'quantum': '#bc8cff', 'neural': '#3fb950',
    'danger': '#f85149', 'warning': '#d29922', 'accent': '#79c0ff', 'highlight': '#f0883e',
}
```

> *"The brain doesn't run on ones and zeros. Its security shouldn't either."*
> — Quantum Intelligence (Kevin Qi + Claude)

**Version:** 3.0 (Working Draft) | **Collaboration:** `{python} FRAMEWORK['collaboration']` | **GitHub:** `{python} FRAMEWORK['github']`

## Abstract

Brain-computer interfaces (BCIs) are advancing from experimental medical devices toward consumer technology, yet their security frameworks remain rooted entirely in classical computing paradigms. This paper introduces the **`{python} FRAMEWORK['name']`** (pronounced "`{python} FRAMEWORK['pronunciation']`"), a 7-band symmetric hourglass (3-1-3) security architecture derived from neuroscience and quantum physics that addresses a critical blind spot: quantum-scale phenomena at the electrode-tissue interface that may be invisible to classical detection, if operationally significant.

We present the QI equation in two complementary forms — an additive engineering model for BCI practitioners and a tensor-product theoretical model for physicists — that unify 21 established equations from classical physics, neuroscience, and quantum mechanics into a single security metric. The framework maps 8 open questions in quantum neuroscience as tunable parameters rather than fixed assumptions, making the equation future-proof by design.

We identify six novel contributions not found in prior literature, including quantum biometrics via ion channel tunneling profiles and Zeno-BCI stabilization. Five testable experimental predictions are proposed for empirical validation.

::: {.callout-note title="AI Transparency Disclosure"}
`{python} FRAMEWORK['ai_transparency']['statement']` For methodology, contribution matrix, and documented corrections, see **[TRANSPARENCY.md](../../main/MAIN/governance/TRANSPARENCY.md)**. For the complete timestamped audit trail — every derivation, AI contribution, validation result, and decision rationale — see **[`{python} FRAMEWORK['ai_transparency']['audit_trail']`](`{python} FRAMEWORK['ai_transparency']['audit_trail']`)**.
:::

---

## Introduction: The Quantum Blind Spot in BCI Security

### The BCI Revolution

```{python}
#| label: neuralink-specs
#| tbl-cap: "Neuralink N1 Specifications"
import pandas as pd
n1 = NEURALINK_N1
df = pd.DataFrame([
    {"Specification": "Electrodes", "Value": str(n1['electrodes'])},
    {"Specification": "Threads", "Value": str(n1['threads'])},
    {"Specification": "Sampling Rate", "Value": f"{n1['sampling_rate_khz']} kHz"},
    {"Specification": "Wireless", "Value": n1['wireless']},
    {"Specification": "Power", "Value": f"{n1['power_mw']} mW"},
    {"Specification": "SoC Area", "Value": f"{n1['soc_area_mm']} mm²"},
])
df.style.hide(axis='index')
```

Current BCI security treats the interface as a classical digital system. But the interface sits at the boundary of quantum and classical physics. Neural tissue is not silicon — it operates at scales where quantum effects may be non-negligible (see Limitations chapter for caveats and the decoherence time debate).

---

## The QIF Layer Architecture (`{python} FRAMEWORK['layer_model_version']`)

The OSI model was designed in 1984 for packet-switched telecommunications. A brain-computer interface is not a packet-switched network. QIF v3.0 removes all OSI heritage — the layer model is derived entirely from neuroscience and quantum physics.

```{python}
#| label: fig-hourglass
#| fig-cap: "QIF v3.0 — 7-Band Hourglass Architecture (3-1-3 symmetric). Width represents state space. Narrowest at I0 (measurement collapses possibilities)."

zone_colors = {z_id: z["color"] for z_id, z in ZONES.items()}

fig, ax = plt.subplots(figsize=(10, 10))
n = len(BANDS)

for i, band in enumerate(BANDS):
    y = n - 1 - i
    color = zone_colors[band["zone"]]
    alpha = 0.95 if band["id"] == "I0" else 0.8

    width = 0.2 + band["hourglass_width"] * 0.7
    x_offset = (1.0 - width) / 2

    rect = plt.Rectangle((x_offset, y), width, 0.85, facecolor=color, alpha=alpha,
                          edgecolor='white', linewidth=2, zorder=2)
    ax.add_patch(rect)
    ax.text(0.5, y + 0.42, f"{band['id']}: {band['name']}",
            ha='center', va='center', fontsize=10, fontweight='bold', color='white', zorder=3)

    qi_lo, qi_hi = band["qi_range"]
    qi_text = f"QI {qi_lo}–{qi_hi}" if qi_hi > 0 else "QI ≈ 0"
    ax.text(0.5 + width / 2 + 0.15, y + 0.42, qi_text,
            ha='left', va='center', fontsize=8, color='gray', zorder=3)

# Zone labels — dynamic
neural_ys = [n - 1 - i for i, b in enumerate(BANDS) if b["zone"] == "neural"]
interface_ys = [n - 1 - i for i, b in enumerate(BANDS) if b["zone"] == "interface"]
silicon_ys = [n - 1 - i for i, b in enumerate(BANDS) if b["zone"] == "silicon"]

ax.text(1.15, sum(neural_ys)/len(neural_ys) + 0.42, 'Neural\nDomain',
        ha='left', va='center', fontsize=10, color=zone_colors['neural'], fontweight='bold')
ax.text(1.15, sum(interface_ys)/len(interface_ys) + 0.42, 'Interface\nZone',
        ha='left', va='center', fontsize=10, color=zone_colors['interface'], fontweight='bold')
ax.text(1.15, sum(silicon_ys)/len(silicon_ys) + 0.42, 'Silicon\nDomain',
        ha='left', va='center', fontsize=10, color=zone_colors['silicon'], fontweight='bold')

# Classical ceiling — between N3 and N2
n3_y = n - 1 - 0 + 0.42
n2_y = n - 1 - 1 + 0.42
ceiling_y = (n3_y + n2_y) / 2
ax.axhline(y=ceiling_y, color='#f39c12', linestyle='--', alpha=0.5, linewidth=1.5, xmin=0.05, xmax=0.95)
ax.text(0.97, ceiling_y + 0.05, 'Classical Ceiling', ha='right', va='bottom', fontsize=8,
        color='#f39c12', fontstyle='italic')

ax.set_xlim(-0.15, 1.5)
ax.set_ylim(-0.5, n + 0.5)
ax.set_aspect('auto')
ax.axis('off')
ax.set_title(f'QIF {FRAMEWORK["layer_model_version"]} — {n}-Band Hourglass Architecture',
             fontsize=14, fontweight='bold', pad=20)
plt.tight_layout()
plt.show()
```

```{python}
#| label: tbl-bands
#| tbl-cap: "QIF v3.0 — 7-Band Hourglass Architecture"

rows = []
for band in BANDS:
    qi_lo, qi_hi = band["qi_range"]
    qi_str = f"{qi_lo}–{qi_hi}" if qi_hi > 0 else "≈ 0"
    regions = ", ".join(band["brain_regions"]) if band["brain_regions"] else "—"
    rows.append({
        "Band": band["id"],
        "Name": band["name"],
        "Zone": ZONES[band["zone"]]["name"],
        "Determinacy": band["determinacy"],
        "QI Range": qi_str,
        "Brain Regions": regions,
    })
pd.DataFrame(rows).style.hide(axis='index')
```

---

## What We Know and What We Don't

> *For every known, the math gives the same answer every time. For every unknown, QIF assigns a variable — so when science fills in the value, the equation already works.*

### The Knowns: Established Science QIF Builds On

```{python}
#| label: tbl-knowns
#| tbl-cap: "Established equations QIF builds on"
knowns = [
    ["Signals have timing jitter", "Phase variance σ²ᵩ", "Coherence metric (Cₛ)", "Established"],
    ["Ion channels have voltage gates", "Hodgkin-Huxley", "Classical BCI security", "Established (1952)"],
    ["Channels have bandwidth limits", "Shannon capacity", "Signal integrity", "Established (1948)"],
    ["Particles tunnel through barriers", "Tunneling coefficient T", "Vulnerability + biometric", "Established"],
    ["Quantum states can't be copied", "No-cloning theorem", "Anti-spoofing", "Established (1982)"],
    ["Measurement disturbs quantum states", "Heisenberg uncertainty", "Eavesdrop detection", "Established (1927)"],
    ["Entangled pairs are correlated", "Bell states", "QKD security", "Established (1964)"],
    ["Frequent measurement freezes evolution", "Quantum Zeno effect", "Zeno-BCI hypothesis", "Established (1977)"],
]
df_k = pd.DataFrame(knowns, columns=["Known", "Equation", "QIF Uses It For", "Status"])
df_k.style.hide(axis='index')
```

### The Unknowns: Where QIF Fills the Gap

```{python}
#| label: tbl-unknowns
#| tbl-cap: "Open questions mapped to QIF variables"
unknowns = [
    ["Decoherence time in neural tissue", "8 OOM disagreement", "Tunable parameter", "τ_D"],
    ["Does the brain use entanglement?", "Posner molecules — unverified", "Model both bio + artificial", "Qentangle"],
    ["Quantum indeterminacy at BCI interface", "No one has quantified it", "Central variable", "Qi"],
    ["Ion channel tunneling uniqueness", "Are profiles unique per person?", "Quantum biometric hypothesis", "Qtunnel"],
    ["Does BCI sampling stabilize quantum states?", "Zeno-BCI — never tested", "Modeled hypothesis", "Zeno term"],
    ["Davydov soliton vulnerability", "THz attack on SNARE?", "Tunneling vulnerability model", "Qtunnel"],
    ["Silicon-tissue quantum boundary", "No framework exists", "I0 Neural Interface", "QIF Band I0"],
    ["Classical-quantum transition shape", "Binary or continuous?", "Continuous dial", "ΓD(t)"],
]
df_u = pd.DataFrame(unknowns, columns=["Unknown", "Mystery", "QIF Approach", "Variable"])
df_u.style.hide(axis='index')
```

---

## The Classical Foundation

### The Coherence Metric

$$C_s = e^{-(\sigma^2_\varphi + \sigma^2_\tau + \sigma^2_\gamma)}$$

```{python}
#| label: fig-coherence-surface
#| fig-cap: "Coherence metric Cₛ drops exponentially as variance increases"

sigma_phi = np.linspace(0, 2, 80)
sigma_tau = np.linspace(0, 2, 80)
PHI, TAU = np.meshgrid(sigma_phi, sigma_tau)
CS = np.exp(-(PHI + TAU + 0.1))

if _USE_PLOTLY:
    fig = go.Figure()
    fig.add_trace(go.Surface(x=PHI, y=TAU, z=CS, colorscale='Viridis', opacity=0.85,
                             colorbar=dict(title='Cₛ'), name='Coherence'))
    fig.add_trace(go.Surface(x=PHI, y=TAU, z=np.full_like(CS, COHERENCE_THRESHOLDS['high']),
                             colorscale=[[0, COLORS['classical']], [1, COLORS['classical']]],
                             opacity=0.15, showscale=False, name=f'High ({COHERENCE_THRESHOLDS["high"]})'))
    fig.add_trace(go.Surface(x=PHI, y=TAU, z=np.full_like(CS, COHERENCE_THRESHOLDS['low']),
                             colorscale=[[0, COLORS['danger']], [1, COLORS['danger']]],
                             opacity=0.15, showscale=False, name=f'Low ({COHERENCE_THRESHOLDS["low"]})'))
    fig.update_layout(template=_plotly_template, title='Coherence Surface (σ²ᵧ = 0.1)',
                      scene=dict(xaxis_title='σ²ᵩ (Phase)', yaxis_title='σ²τ (Transport)',
                                 zaxis_title='Cₛ', camera=dict(eye=dict(x=1.5, y=1.5, z=1.0))),
                      height=600, margin=dict(l=0, r=0, t=40, b=0))
    fig.show()
else:
    fig = plt.figure(figsize=(10, 7))
    ax = fig.add_subplot(111, projection='3d')
    surf = ax.plot_surface(PHI, TAU, CS, cmap='viridis', alpha=0.85, edgecolor='none')
    ax.plot_surface(PHI, TAU, np.full_like(CS, COHERENCE_THRESHOLDS['high']), alpha=0.15, color=COLORS['classical'])
    ax.plot_surface(PHI, TAU, np.full_like(CS, COHERENCE_THRESHOLDS['low']), alpha=0.15, color=COLORS['danger'])
    ax.set_xlabel('σ²ᵩ (Phase)'); ax.set_ylabel('σ²τ (Transport)'); ax.set_zlabel('Cₛ')
    ax.set_title('Coherence Surface (σ²ᵧ = 0.1)'); ax.view_init(elev=25, azim=45)
    fig.colorbar(surf, ax=ax, shrink=0.5); plt.show()
```

**Decision Thresholds** (from config):

```{python}
#| label: tbl-decisions
#| tbl-cap: "Coherence decision matrix"
df_dec = pd.DataFrame(DECISION_MATRIX)
df_dec.columns = ['Coherence Level', 'Auth Status', 'Action']
df_dec.style.hide(axis='index')
```

### Scale-Frequency Relationship

$$v = f \times \lambda$$

```{python}
#| label: fig-scale-freq
#| fig-cap: "Higher frequency = more local coherence (Buzsáki & Draguhn 2004)"

freqs = [b['freq_mid'] for b in FREQUENCY_BANDS]
spatials = [b['spatial_mid_m'] for b in FREQUENCY_BANDS]
band_names = [b['band'] for b in FREQUENCY_BANDS]
log_f, log_s = np.log10(freqs), np.log10(spatials)
coeffs = np.polyfit(log_f, log_s, 1)
trend_f = np.logspace(-0.5, 2.5, 100)
trend_s = 10**(coeffs[0]*np.log10(trend_f) + coeffs[1])

if _USE_PLOTLY:
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=freqs, y=spatials, mode='markers+text', text=band_names,
                             textposition='top right', textfont=dict(color=COLORS['accent'], size=10),
                             marker=dict(size=12, color=COLORS['quantum']), name='Bands',
                             hovertemplate='%{text}<br>Freq: %{x:.1f} Hz<br>Extent: %{y:.3f} m<extra></extra>'))
    fig.add_trace(go.Scatter(x=trend_f.tolist(), y=trend_s.tolist(), mode='lines',
                             line=dict(color=COLORS['warning'], dash='dash', width=1.5),
                             name=f'Power law (slope={coeffs[0]:.2f})', opacity=0.5))
    fig.add_hline(y=BRAIN_MAX_DIMENSION_M, line_dash='dash', line_color=COLORS['danger'],
                  opacity=0.7, annotation_text=f'Brain max ({BRAIN_MAX_DIMENSION_M*100:.0f} cm)')
    fig.update_xaxes(type='log', title='Frequency (Hz)')
    fig.update_yaxes(type='log', title='Coherent Spatial Extent (m)')
    fig.update_layout(template=_plotly_template, title='Scale-Frequency Relationship',
                      height=500, showlegend=True)
    fig.show()
else:
    fig, ax = plt.subplots(figsize=(10, 6))
    for band in FREQUENCY_BANDS:
        ax.plot(band['freq_mid'], band['spatial_mid_m'], 'o', markersize=10, color=COLORS['quantum'])
        ax.annotate(band['band'], (band['freq_mid'], band['spatial_mid_m']),
                    textcoords="offset points", xytext=(10, 10), fontsize=9, color=COLORS['accent'])
    ax.axhline(y=BRAIN_MAX_DIMENSION_M, color=COLORS['danger'], linestyle='--', alpha=0.7,
               label=f'Brain max ({BRAIN_MAX_DIMENSION_M*100:.0f} cm)')
    ax.plot(trend_f, trend_s, '--', color=COLORS['warning'], alpha=0.5, label=f'Power law (slope={coeffs[0]:.2f})')
    ax.set_xscale('log'); ax.set_yscale('log')
    ax.set_xlabel('Frequency (Hz)'); ax.set_ylabel('Coherent Spatial Extent (m)')
    ax.set_title('Scale-Frequency Relationship'); ax.legend(); ax.grid(True, alpha=0.3)
    plt.show()
```

---

## The QI Equation: Two Complementary Views

### Candidate 1: The Engineering Equation

$$QI(t) = \alpha \cdot C_{class} + \beta \cdot (1 - \Gamma_D(t)) \cdot [Q_i + \delta \cdot Q_{entangle}] - \gamma \cdot Q_{tunnel}$$

where $\Gamma_D(t) = 1 - e^{-t/\tau_D}$

```{python}
#| label: fig-qi-components
#| fig-cap: "QI equation components at three decoherence regimes"

tau_d = DEFAULT_C1_PARAMS['tau_d']
times = [1e-8, 1e-5, 1e-2]
labels = ['t << τ_D (Quantum)', 't ≈ τ_D (Hybrid)', 't >> τ_D (Classical)']
params = QICandidate1Params(**{k: v for k, v in DEFAULT_C1_PARAMS.items()})

c_vals, qi_vals, ent_vals, tun_vals = [], [], [], []
for t in times:
    gate = quantum_gate(t, tau_d)
    c_vals.append(params.alpha * 0.8)
    qi_vals.append(params.beta * gate * 0.5)
    ent_vals.append(params.beta * gate * params.delta * 0.3)
    tun_vals.append(params.gamma * 0.1)

if _USE_PLOTLY:
    fig = go.Figure()
    fig.add_trace(go.Bar(x=labels, y=c_vals, name='α·Cclass', marker_color=COLORS['classical'],
                         hovertemplate='%{y:.4f}<extra>α·Cclass</extra>'))
    fig.add_trace(go.Bar(x=labels, y=qi_vals, name='β·gate·Qi', marker_color=COLORS['quantum'],
                         hovertemplate='%{y:.4f}<extra>β·gate·Qi</extra>'))
    fig.add_trace(go.Bar(x=labels, y=ent_vals, name='β·gate·δ·Qentangle', marker_color=COLORS['neural'],
                         hovertemplate='%{y:.4f}<extra>β·gate·δ·Qentangle</extra>'))
    fig.add_trace(go.Bar(x=labels, y=[-t for t in tun_vals], name='-γ·Qtunnel',
                         marker_color=COLORS['danger'], opacity=0.7,
                         hovertemplate='%{y:.4f}<extra>-γ·Qtunnel</extra>'))
    fig.update_layout(template=_plotly_template, barmode='relative',
                      title='Candidate 1 — Component Breakdown',
                      yaxis_title='QI Score Components', height=500)
    fig.show()
else:
    fig, ax = plt.subplots(figsize=(10, 6))
    x = np.arange(len(times))
    ax.bar(x, c_vals, 0.6, label='α·Cclass', color=COLORS['classical'])
    ax.bar(x, qi_vals, 0.6, bottom=c_vals, label='β·gate·Qi', color=COLORS['quantum'])
    bottoms = [c+q for c,q in zip(c_vals, qi_vals)]
    ax.bar(x, ent_vals, 0.6, bottom=bottoms, label='β·gate·δ·Qentangle', color=COLORS['neural'])
    ax.bar(x, [-t for t in tun_vals], 0.6, label='-γ·Qtunnel', color=COLORS['danger'], alpha=0.7)
    ax.set_xticks(x); ax.set_xticklabels(labels)
    ax.set_ylabel('QI Score Components'); ax.set_title('Candidate 1 — Component Breakdown')
    ax.legend(loc='upper right'); ax.grid(True, alpha=0.2, axis='y'); ax.axhline(y=0, color='white', linewidth=0.5)
    plt.show()
```

### Candidate 2: The Theoretical Equation

$$QI = C_{class} \otimes e^{-S_{quantum}}$$

where $S_{quantum} = S_{vN}(\rho(t)) + \lambda \cdot \Phi_{tunnel} - \mu \cdot E(\rho_{AB})$

---

## Novel Contributions

### Quantum Tunneling as Biometric

```{python}
#| label: fig-biometric
#| fig-cap: "Ion channel tunneling profiles are unique per person — a quantum biometric"

energies = np.linspace(0.01, 0.95, 200)
profiles = [
    {"V0": 1.0, "d": 0.8e-9, "label": "Person A", "color": COLORS['classical']},
    {"V0": 1.1, "d": 0.9e-9, "label": "Person B", "color": COLORS['quantum']},
    {"V0": 0.95, "d": 1.0e-9, "label": "Person C", "color": COLORS['neural']},
]

if _USE_PLOTLY:
    fig = go.Figure()
    for p in profiles:
        T_vals = [tunneling_coefficient(p["V0"], E, p["d"]) for E in energies]
        fig.add_trace(go.Scatter(x=energies.tolist(), y=T_vals, mode='lines',
                                 name=p['label'], line=dict(color=p['color'], width=2.5),
                                 hovertemplate='E=%{x:.3f} eV<br>T(E)=%{y:.2e}<extra>%{fullData.name}</extra>'))
    fig.update_yaxes(type='log', range=[-20, 0], title='Tunneling Probability T(E)')
    fig.update_xaxes(title='Particle Energy (eV)')
    fig.update_layout(template=_plotly_template,
                      title='Quantum Biometric — Unique Ion Channel Tunneling Profiles', height=500)
    fig.show()
else:
    fig, ax = plt.subplots(figsize=(10, 6))
    for p in profiles:
        T_vals = [tunneling_coefficient(p["V0"], E, p["d"]) for E in energies]
        ax.semilogy(energies, T_vals, linewidth=2.5, label=p["label"], color=p["color"])
    ax.set_xlabel('Particle Energy (eV)'); ax.set_ylabel('Tunneling Probability T(E)')
    ax.set_title('Quantum Biometric — Unique Ion Channel Tunneling Profiles')
    ax.legend(); ax.grid(True, alpha=0.3); ax.set_ylim(1e-20, 1)
    plt.show()
```

### Von Neumann Entropy Non-Monotonicity

```{python}
#| label: fig-entropy
#| fig-cap: "The quantum security paradox: the part is more uncertain than the whole"

_entropy_labels = ['Subsystem A', 'Subsystem B', 'Total AB']
_shannon = [0.5, 0.3, 0.7]
_vn = [np.log(2), np.log(2), 0.0]

if _USE_PLOTLY:
    from plotly.subplots import make_subplots
    fig = make_subplots(rows=1, cols=2, subplot_titles=['Classical: Subsystem ≤ Total', 'Quantum: Subsystem > Total!'])
    fig.add_trace(go.Bar(x=_entropy_labels, y=_shannon,
                         marker_color=[COLORS['classical'], COLORS['classical'], COLORS['accent']],
                         opacity=0.8, hovertemplate='%{x}: %{y:.3f}<extra>Shannon</extra>'), row=1, col=1)
    fig.add_trace(go.Bar(x=_entropy_labels, y=_vn,
                         marker_color=[COLORS['quantum'], COLORS['quantum'], COLORS['danger']],
                         opacity=0.8, hovertemplate='%{x}: %{y:.3f}<extra>Von Neumann</extra>'), row=1, col=2)
    fig.add_annotation(x='Total AB', y=0.03, text='ZERO (pure entangled)',
                       showarrow=False, font=dict(color=COLORS['danger'], size=10), row=1, col=2)
    fig.update_yaxes(range=[0, 1.0], title='Shannon Entropy', row=1, col=1)
    fig.update_yaxes(range=[0, 1.0], title='Von Neumann Entropy', row=1, col=2)
    fig.update_layout(template=_plotly_template, title='Quantum Security Paradox',
                      height=450, showlegend=False)
    fig.show()
else:
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
    ax1.bar(_entropy_labels, _shannon,
            color=[COLORS['classical'], COLORS['classical'], COLORS['accent']], alpha=0.8, edgecolor='white')
    ax1.set_ylabel('Shannon Entropy'); ax1.set_title('Classical: Subsystem ≤ Total'); ax1.set_ylim(0, 1.0)
    ax2.bar(_entropy_labels, _vn,
            color=[COLORS['quantum'], COLORS['quantum'], COLORS['danger']], alpha=0.8, edgecolor='white')
    ax2.set_ylabel('Von Neumann Entropy'); ax2.set_title('Quantum: Subsystem > Total!'); ax2.set_ylim(0, 1.0)
    ax2.annotate('ZERO (pure entangled)', xy=(2, 0.02), fontsize=9, ha='center', color=COLORS['danger'], fontweight='bold')
    fig.suptitle('Quantum Security Paradox', fontsize=13, y=1.02); fig.tight_layout()
    plt.show()
```

---

## The Decoherence Spectrum

$\tau_D$ is a tunable parameter — the equation works at ANY timescale.

```{python}
#| label: fig-decoherence
#| fig-cap: "QIF works across all disputed decoherence timescales"

t_range = np.logspace(-15, 5, 500)
t_range2 = np.logspace(-8, 0, 200)
qi_cl = qi_candidate1(0.8, 0.5, 0.3, 0.1, 1e10, QICandidate1Params(tau_d=1e-15))

if _USE_PLOTLY:
    from plotly.subplots import make_subplots
    fig = make_subplots(rows=1, cols=2, subplot_titles=['Decoherence Factor', 'Security Decay'])
    for camp in DECOHERENCE_CAMPS:
        tau = camp['tau_d']
        gamma_d = [decoherence_factor(t, tau) for t in t_range]
        fig.add_trace(go.Scatter(x=t_range.tolist(), y=gamma_d, mode='lines', name=camp['camp'],
                                 line=dict(width=2),
                                 hovertemplate='t=%{x:.2e} s<br>ΓD=%{y:.4f}<extra>%{fullData.name}</extra>'),
                      row=1, col=1)
    fig.add_hline(y=0.5, line_dash='dash', line_color=COLORS['warning'], opacity=0.5, row=1, col=1)
    for camp in DECOHERENCE_CAMPS:
        tau = camp['tau_d']
        scores = [qi_candidate1(0.8, 0.5, 0.3, 0.1, t, QICandidate1Params(tau_d=tau)) for t in t_range2]
        fig.add_trace(go.Scatter(x=t_range2.tolist(), y=scores, mode='lines', name=camp['camp'],
                                 line=dict(width=2), showlegend=False,
                                 hovertemplate='t=%{x:.2e} s<br>QI=%{y:.4f}<extra>%{fullData.name}</extra>'),
                      row=1, col=2)
    fig.add_hline(y=qi_cl, line_dash='dot', line_color=COLORS['danger'], opacity=0.7,
                  annotation_text='Classical only', row=1, col=2)
    fig.update_xaxes(type='log', title='Time (s)', row=1, col=1)
    fig.update_xaxes(type='log', title='Time (s)', row=1, col=2)
    fig.update_yaxes(title='ΓD(t)', range=[-0.05, 1.05], row=1, col=1)
    fig.update_yaxes(title='QI Score', row=1, col=2)
    fig.update_layout(template=_plotly_template, height=450)
    fig.show()
else:
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))
    for camp in DECOHERENCE_CAMPS:
        tau = camp['tau_d']
        gamma_d = np.array([decoherence_factor(t, tau) for t in t_range])
        ax1.semilogx(t_range, gamma_d, linewidth=2, label=camp['camp'])
    ax1.axhline(y=0.5, color=COLORS['warning'], linestyle='--', alpha=0.5, label='50%')
    ax1.set_xlabel('Time (s)'); ax1.set_ylabel('ΓD(t)'); ax1.set_title('Decoherence Factor')
    ax1.legend(fontsize=9); ax1.set_ylim(-0.05, 1.05); ax1.grid(True, alpha=0.3)
    for camp in DECOHERENCE_CAMPS:
        tau = camp['tau_d']
        scores = [qi_candidate1(0.8, 0.5, 0.3, 0.1, t, QICandidate1Params(tau_d=tau)) for t in t_range2]
        ax2.semilogx(t_range2, scores, linewidth=2, label=camp['camp'])
    ax2.axhline(y=qi_cl, color=COLORS['danger'], linestyle=':', alpha=0.7, label='Classical only')
    ax2.set_xlabel('Time (s)'); ax2.set_ylabel('QI Score'); ax2.set_title('Security Decay')
    ax2.legend(fontsize=9); ax2.grid(True, alpha=0.3)
    fig.tight_layout(); plt.show()
```

```{python}
#| label: tbl-decoherence
#| tbl-cap: "Disputed decoherence timescales — QIF works at all of them"
df_dec = pd.DataFrame(DECOHERENCE_CAMPS)
df_dec.columns = ['Camp', 'τ_D (seconds)', 'Label', 'Implication']
df_dec.style.hide(axis='index')
```

---

## Scenario Testing

```{python}
#| label: fig-scenarios
#| fig-cap: "QIF correctly distinguishes healthy signals from attacks"

names, coherences, c1s, c2s, attacks = [], [], [], [], []

for name, scenario in SCENARIOS.items():
    if name in ('quantum_regime_short', 'decoherence_boundary'):
        continue
    data = generate_custom_signals(scenario)
    result = full_qi_assessment(
        phases=data['phases'], transport_probs=data['transport_probs'],
        amplitudes=data['amplitudes'], t=1e-6, tau_d=1e-5)
    names.append(scenario.name.replace(' ', '\n'))
    coherences.append(result.coherence)
    c1s.append(result.qi_score_c1)
    c2s.append(result.qi_score_c2)
    attacks.append(scenario.is_attack)

bar_colors = [COLORS['danger'] if a else COLORS['neural'] for a in attacks]

if _USE_PLOTLY:
    from plotly.subplots import make_subplots
    fig = make_subplots(rows=1, cols=2, subplot_titles=['Coherence Metric', 'Both Candidates'])
    fig.add_trace(go.Bar(x=names, y=coherences, marker_color=bar_colors, opacity=0.8,
                         hovertemplate='%{x}<br>Cₛ=%{y:.4f}<extra></extra>'), row=1, col=1)
    fig.add_hline(y=COHERENCE_THRESHOLDS['high'], line_dash='dash', line_color=COLORS['classical'],
                  opacity=0.7, annotation_text=f'High ({COHERENCE_THRESHOLDS["high"]})', row=1, col=1)
    fig.add_hline(y=COHERENCE_THRESHOLDS['low'], line_dash='dash', line_color=COLORS['warning'],
                  opacity=0.7, annotation_text=f'Low ({COHERENCE_THRESHOLDS["low"]})', row=1, col=1)
    fig.add_trace(go.Bar(x=names, y=c1s, name='C1 (Engineering)', marker_color=COLORS['classical'],
                         opacity=0.8, hovertemplate='%{x}<br>C1=%{y:.4f}<extra></extra>'), row=1, col=2)
    fig.add_trace(go.Bar(x=names, y=c2s, name='C2 (Theoretical)', marker_color=COLORS['quantum'],
                         opacity=0.8, hovertemplate='%{x}<br>C2=%{y:.4f}<extra></extra>'), row=1, col=2)
    fig.update_yaxes(title='Cₛ', row=1, col=1)
    fig.update_yaxes(title='QI Score', row=1, col=2)
    fig.update_layout(template=_plotly_template, height=500, barmode='group')
    fig.show()
else:
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))
    x = np.arange(len(names))
    ax1.bar(x, coherences, color=bar_colors, alpha=0.8, edgecolor='white', linewidth=0.5)
    ax1.axhline(y=COHERENCE_THRESHOLDS['high'], color=COLORS['classical'], linestyle='--', alpha=0.7, label=f'High ({COHERENCE_THRESHOLDS["high"]})')
    ax1.axhline(y=COHERENCE_THRESHOLDS['low'], color=COLORS['warning'], linestyle='--', alpha=0.7, label=f'Low ({COHERENCE_THRESHOLDS["low"]})')
    ax1.set_xticks(x); ax1.set_xticklabels(names, fontsize=7)
    ax1.set_ylabel('Cₛ'); ax1.set_title('Coherence Metric'); ax1.legend(fontsize=8)
    w = 0.35
    ax2.bar(x-w/2, c1s, w, label='C1 (Engineering)', color=COLORS['classical'], alpha=0.8)
    ax2.bar(x+w/2, c2s, w, label='C2 (Theoretical)', color=COLORS['quantum'], alpha=0.8)
    ax2.set_xticks(x); ax2.set_xticklabels(names, fontsize=7)
    ax2.set_ylabel('QI Score'); ax2.set_title('Both Candidates'); ax2.legend()
    fig.tight_layout(); plt.show()
```

---

## Threat Model

```{python}
#| label: tbl-threats
#| tbl-cap: "QIF threat model — quantum detection fills classical blind spots"
df_threats = pd.DataFrame(THREAT_MODEL)
df_threats.columns = ['Attack', 'Band(s)', 'Classical Detection?', 'Quantum Detection?']
df_threats.style.hide(axis='index')
```

---

## Experimental Predictions

| # | Prediction | How to Test | Expected Outcome |
|---|-----------|-------------|------------------|
| 1 | Ion channel tunneling profiles are unique per individual | Single-channel patch clamp + quantum state tomography | Significant inter-subject T(E) variation |
| 2 | 1kHz+ BCI sampling stabilizes quantum coherence (Zeno) | Vary sampling rate, measure coherence time | Coherence increases above threshold rate |
| 3 | Davydov solitons generated by THz radiation | THz stimulation of SNARE complexes in vitro | Anomalous vesicle release at THz frequency |
| 4 | Decoherence at BCI interface is measurable | Quantum state tomography at electrode-tissue junction | τ_D measurement resolving camps |
| 5 | QI score drops under quantum-level attack | Simulated attack on BCI testbed | QI(t) decreases vs baseline |

---

## Encyclopedia of Terms

::: {.callout-note collapse="true" title="Click to expand full encyclopedia"}

**Action Potential** — An electrical pulse that travels along a nerve cell. Duration ~1-2 ms, speed 1-100 m/s. Modeled by Hodgkin-Huxley equation.

**BCI (Brain-Computer Interface)** — A device creating direct communication between brain and computer. Example: Neuralink N1 (`{python} NEURALINK_N1['electrodes']` electrodes, `{python} NEURALINK_N1['sampling_rate_khz']` kHz sampling).

**Bell States** — Maximally entangled qubit pairs: |Phi+> = (1/sqrt(2))(|00> + |11>). Used in QKD protocols (E91).

**Born Rule** — P(x) = |psi(x)|^2. The fundamental rule connecting quantum math to measurement probability.

**Coherence (Neural)** — Synchronized neural oscillations. High coherence = effective communication. QIF's Cs quantifies this.

**Coherence (Quantum)** — Ability to exist in superposition. Fragile — destroyed by decoherence.

**Davydov Soliton** — Quantum quasiparticle propagating along protein alpha-helices. Can trigger synaptic vesicle release via tunneling through SNARE complexes. QIF identifies as attack vector.

**Decoherence** — Loss of quantum properties through environmental interaction. Time constant: tau_D (disputed: `{python} DECOHERENCE_CAMPS[0]['label']` to `{python} DECOHERENCE_CAMPS[2]['label']`).

**Entanglement** — Non-classical correlation between quantum particles. Measuring one instantly affects the other. NOT faster-than-light communication.

**Fisher's Posner Molecules** — Hypothesis: Ca9(PO4)6 nanoclusters sustain entanglement for hours via P-31 nuclear spins. Speculative, unverified.

**Grover's Algorithm** — O(sqrt(N)) quantum search. Provably optimal. Halves effective key lengths for symmetric crypto.

**Heisenberg Uncertainty** — DxDp >= hbar/2. Cannot simultaneously know exact position and momentum. Guarantees eavesdropper detection.

**No-Cloning Theorem** — Impossible to copy an arbitrary unknown quantum state. Guarantees quantum-secured signals can't be replicated.

**Quantum Biometric** (Novel) — Ion channel tunneling profile as unforgeable identity. Unique per person, unclonable by physics.

**Robertson-Schrodinger** — Generalized uncertainty: exact equality for qubits. QIF can compute indeterminacy exactly.

**Shor's Algorithm** — O(n^3) quantum factoring. RSA-2048: `{python} QUANTUM_THREATS[0]['value']` (`{python} QUANTUM_THREATS[0]['source']`).

**tau_D (Decoherence Time)** — How long quantum effects persist. Greek tau = time constant, D = decoherence. QIF treats as tunable parameter.

**Von Neumann Entropy** — S(rho) = -Tr(rho ln rho). Quantum uncertainty measure. Subsystem can exceed total (entanglement signature).

**Zeno Effect (Quantum)** — Frequent measurement freezes quantum evolution. QIF hypothesis: BCI's 1kHz+ sampling may stabilize quantum states.

:::

---

*QIF Whitepaper v3.1 — Generated from code. Change the equation, re-render, paper updates.*

*Authors: Kevin Qi, with Claude (Anthropic) | Quantum Intelligence (QI) | 2026-02-02*
