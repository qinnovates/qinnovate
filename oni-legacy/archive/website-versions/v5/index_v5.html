<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XNPBK7CRGG"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-XNPBK7CRGG');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ONI | Neurosecurity Standards for Brain-Computer Interfaces</title>
    <meta name="description" content="BCIs are being implanted in humans today — with no security standard. ONI is building one. 14 layers extending OSI into the biological domain.">
    <meta name="keywords" content="neurosecurity, neural interface, brain-computer interface, ONI model, neural security standard, neuroethics">

    <!-- Content Security Policy -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://unpkg.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://www.googletagmanager.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; img-src 'self' https: data:; connect-src 'self' https://raw.githubusercontent.com https://api.github.com https://www.google-analytics.com https://analytics.google.com; font-src 'self' https://fonts.gstatic.com;">

    <!-- Open Graph -->
    <meta property="og:title" content="ONI | Neurosecurity Standards for BCIs">
    <meta property="og:description" content="The neural security standard. 14 layers extending OSI to protect brain-computer interfaces.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://qinnovates.github.io/ONI/">
    <meta property="og:image" content="https://qinnovates.github.io/ONI/images/ONI_Banner_Logo.png">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

    <!-- Three.js -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

    <!-- GSAP + ScrollTrigger -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>

    <style>
        /* ============================================
           CSS RESET & VARIABLES
           ============================================ */
        :root {
            --bg-deep: #050a14;
            --bg-primary: #0a0f1a;
            --bg-card: rgba(15, 23, 42, 0.7);
            --bg-card-hover: rgba(20, 30, 50, 0.85);
            --accent-blue: #3b82f6;
            --accent-purple: #8b5cf6;
            --accent-cyan: #06b6d4;
            --accent-amber: #f59e0b;
            --accent-green: #10b981;
            --accent-pink: #ec4899;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --text-dim: #475569;
            --border: rgba(30, 41, 59, 0.8);
            --gradient-blue-purple: linear-gradient(135deg, #3b82f6, #8b5cf6);
            --gradient-blue-cyan: linear-gradient(135deg, #3b82f6, #06b6d4);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html {
            scroll-behavior: smooth;
            background: var(--bg-deep);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-deep);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* ============================================
           NAVIGATION
           ============================================ */
        nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            padding: 0 2rem;
            height: 64px;
            display: flex;
            align-items: center;
            background: rgba(5, 10, 20, 0.8);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(30, 41, 59, 0.4);
            transition: background 0.3s, border-color 0.3s;
        }

        nav.scrolled {
            background: rgba(5, 10, 20, 0.95);
            border-bottom-color: rgba(30, 41, 59, 0.7);
        }

        .nav-inner {
            max-width: 1280px;
            margin: 0 auto;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-logo {
            font-size: 1.35rem;
            font-weight: 700;
            color: var(--text-primary);
            text-decoration: none;
            letter-spacing: -0.02em;
        }

        .nav-links {
            display: flex;
            gap: 2rem;
            list-style: none;
            align-items: center;
        }

        .nav-links a {
            color: var(--text-muted);
            text-decoration: none;
            font-size: 0.875rem;
            font-weight: 500;
            transition: color 0.2s;
            position: relative;
        }

        .nav-links a:hover,
        .nav-links a.active {
            color: var(--text-primary);
        }

        .nav-links a.active::after {
            content: '';
            position: absolute;
            bottom: -4px;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--accent-blue);
            border-radius: 1px;
        }

        .nav-github {
            display: flex;
            align-items: center;
            color: var(--text-muted) !important;
            transition: color 0.2s;
        }

        .nav-github:hover { color: var(--text-primary) !important; }

        .nav-github svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        /* Mobile hamburger */
        .nav-hamburger {
            display: none;
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px;
        }

        .nav-hamburger svg {
            width: 24px;
            height: 24px;
            fill: none;
            stroke: currentColor;
            stroke-width: 2;
        }

        .nav-mobile-menu {
            display: none;
            position: fixed;
            top: 64px;
            left: 0;
            right: 0;
            background: rgba(5, 10, 20, 0.98);
            backdrop-filter: blur(20px);
            padding: 1rem 2rem 2rem;
            border-bottom: 1px solid var(--border);
            z-index: 999;
        }

        .nav-mobile-menu.open { display: flex; flex-direction: column; gap: 1rem; }

        .nav-mobile-menu a {
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 1rem;
            font-weight: 500;
            padding: 0.5rem 0;
        }

        @media (max-width: 768px) {
            .nav-links { display: none; }
            .nav-hamburger { display: block; }
        }

        /* ============================================
           SCENE SHARED STYLES
           ============================================ */
        .scene {
            position: relative;
            overflow: hidden;
        }

        .scene-inner {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        .section-label {
            font-size: 0.75rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: var(--accent-blue);
            font-weight: 600;
            margin-bottom: 1rem;
        }

        /* ============================================
           SCENE 1: HERO
           ============================================ */
        #scene-hero {
            height: 100vh;
            min-height: 700px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        #three-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
            pointer-events: none;
        }

        .hero-content {
            position: relative;
            z-index: 2;
            text-align: center;
            max-width: 900px;
            padding: 13vh 2rem 0;
        }

        .hero-mission {
            font-size: clamp(0.95rem, 1.8vw, 1.15rem);
            color: var(--text-secondary);
            font-weight: 400;
            line-height: 1.7;
            max-width: 620px;
            margin: 0 auto 1.75rem;
            opacity: 0;
        }

        .hero-mission em {
            color: var(--text-primary);
            font-style: normal;
            font-weight: 500;
        }

        .hero-label {
            font-size: 0.75rem;
            letter-spacing: 0.25em;
            text-transform: uppercase;
            color: #d4a543;
            font-weight: 600;
            margin-bottom: 1.5rem;
            opacity: 0;
        }

        .hero-title {
            font-size: clamp(2.5rem, 5.5vw, 4.5rem);
            font-weight: 800;
            letter-spacing: -0.03em;
            line-height: 1.1;
            margin-bottom: 1.5rem;
            color: var(--text-primary);
        }

        .hero-title .word {
            display: inline-block;
            opacity: 0;
            transform: translateY(20px);
        }

        .hero-subtitle {
            font-size: clamp(1rem, 2vw, 1.35rem);
            color: var(--text-primary);
            font-weight: 400;
            max-width: 650px;
            margin: 0 auto 2.5rem;
            line-height: 1.6;
            opacity: 0;
        }

        .hero-cta {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem 2rem;
            background: #000000;
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: var(--text-primary);
            text-decoration: none;
            font-weight: 600;
            font-size: 0.95rem;
            border-radius: 100px;
            transition: all 0.3s;
            opacity: 0;
        }

        .hero-cta:hover {
            background: #111111;
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
        }

        .hero-scroll-indicator {
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2;
            opacity: 0;
            animation: float-bounce 2s ease-in-out infinite;
        }

        @keyframes float-bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(8px); }
        }

        .hero-scroll-text {
            display: block;
            font-size: 0.7rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: var(--text-primary);
            text-align: center;
        }

        .hero-scroll-indicator svg {
            display: block;
            margin: 0.5rem auto 0;
            width: 24px;
            height: 24px;
            stroke: #ffffff;
            fill: none;
            stroke-width: 2;
        }

        /* ============================================
           SCENE 2: THE PROBLEM
           ============================================ */
        #scene-problem {
            min-height: 100vh;
            display: flex;
            align-items: center;
            padding: 8rem 0;
            position: relative;
            z-index: 1;
            background: linear-gradient(180deg,
                rgba(5, 10, 20, 0) 0%,
                rgba(5, 10, 20, 0.8) 15%,
                rgba(5, 10, 20, 0.8) 85%,
                rgba(5, 10, 20, 0) 100%);
        }

        .problem-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6rem;
            align-items: center;
        }

        .problem-text h2 {
            font-size: clamp(2rem, 3.5vw, 3rem);
            font-weight: 700;
            letter-spacing: -0.02em;
            line-height: 1.15;
            margin-bottom: 1.5rem;
        }

        .problem-text p {
            color: var(--text-secondary);
            font-size: 1.05rem;
            line-height: 1.7;
            max-width: 520px;
        }

        .problem-stats {
            display: flex;
            flex-direction: column;
            gap: 3rem;
        }

        .stat-item {
            opacity: 0;
            transform: translateX(30px);
        }

        .stat-number {
            font-size: clamp(3rem, 5vw, 4.5rem);
            font-weight: 800;
            letter-spacing: -0.03em;
            line-height: 1;
            margin-bottom: 0.25rem;
        }

        .stat-number.blue {
            background: var(--gradient-blue-purple);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stat-number.amber {
            color: var(--accent-amber);
        }

        .stat-number.red {
            color: #ef4444;
        }

        .stat-desc {
            font-size: 0.95rem;
            color: var(--text-muted);
        }

        /* ============================================
           SCENE 3: THE FRAMEWORK (Scroll-driven 3D)
           ============================================ */
        #scene-framework {
            position: relative;
            z-index: 1;
            background: transparent;
        }

        .framework-scroll-track {
            position: relative;
        }

        .framework-intro-trigger,
        .framework-closing-trigger {
            height: 50vh;
            position: relative;
        }

        .framework-interactive-zone {
            height: 120vh;
            position: relative;
        }

        #three-canvas.interactive {
            pointer-events: auto;
            cursor: default;
        }

        /* Click-to-explore hint */
        .click-hint {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 0.6rem;
            color: rgba(255, 255, 255, 0.5);
            font-family: 'Inter', sans-serif;
            font-size: 0.85rem;
            letter-spacing: 0.05em;
            pointer-events: none;
            opacity: 0;
        }
        .click-hint.visible {
            animation: hintPulse 2.5s ease-in-out infinite;
        }
        .click-hint-icon {
            opacity: 0.6;
        }
        @keyframes hintPulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }

        /* Easter egg overlay */
        .easter-egg-overlay {
            position: fixed;
            inset: 0;
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(5, 10, 20, 0);
            backdrop-filter: blur(0px);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.8s ease, background 0.8s ease, backdrop-filter 0.8s ease;
        }
        .easter-egg-overlay.visible {
            opacity: 1;
            background: rgba(5, 10, 20, 0.85);
            backdrop-filter: blur(12px);
            pointer-events: auto;
        }
        .easter-egg-content {
            text-align: center;
            max-width: 480px;
            padding: 2rem;
            transform: scale(0.8) translateY(20px);
            transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .easter-egg-overlay.visible .easter-egg-content {
            transform: scale(1) translateY(0);
        }
        .easter-egg-heart {
            width: 80px;
            height: 72px;
            margin: 0 auto 1.5rem;
            animation: heartbeat 1.4s ease-in-out infinite;
            cursor: pointer;
            filter: drop-shadow(0 0 20px rgba(236, 72, 153, 0.5));
        }
        .easter-egg-heart svg { width: 100%; height: 100%; }
        @keyframes btnPulseGlow {
            0%, 100% {
                box-shadow: 0 0 8px rgba(212,175,55,0.2), 0 0 20px rgba(212,175,55,0.1);
                border-color: rgba(212,175,55,0.4);
            }
            50% {
                box-shadow: 0 0 14px rgba(212,175,55,0.5), 0 0 35px rgba(212,175,55,0.25);
                border-color: rgba(212,175,55,0.7);
            }
        }
        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            15% { transform: scale(1.15); }
            30% { transform: scale(1); }
            45% { transform: scale(1.1); }
            60% { transform: scale(1); }
        }
        .easter-egg-text {
            color: rgba(255, 255, 255, 0.85);
            font-size: 1rem;
            line-height: 1.7;
            font-family: 'Inter', sans-serif;
            font-weight: 300;
            letter-spacing: 0.01em;
        }
        .easter-egg-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.4);
            font-size: 1.8rem;
            cursor: pointer;
            transition: color 0.2s;
            line-height: 1;
        }
        .easter-egg-close:hover { color: rgba(255, 255, 255, 0.8); }

        /* Hover tooltip (cursor-following) */
        .hover-tooltip {
            position: fixed;
            z-index: 20;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(10, 15, 30, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 6px;
            padding: 0.35rem 0.7rem;
            white-space: nowrap;
            font-family: 'Inter', sans-serif;
            font-size: 0.8rem;
        }
        .hover-tooltip.visible {
            opacity: 1;
        }
        .hover-tooltip-zone {
            font-weight: 700;
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            padding: 0.1rem 0.35rem;
            border-radius: 3px;
            line-height: 1.2;
        }
        .hover-tooltip-zone.zone-osi {
            background: rgba(30, 90, 180, 0.35);
            border: 1px solid rgba(55, 130, 235, 0.5);
            color: rgba(120, 180, 255, 0.95);
        }
        .hover-tooltip-zone.zone-gateway {
            background: rgba(217, 119, 6, 0.3);
            border: 1px solid rgba(245, 158, 11, 0.5);
            color: rgba(253, 200, 100, 0.95);
        }
        .hover-tooltip-zone.zone-oni {
            background: rgba(22, 120, 60, 0.35);
            border: 1px solid rgba(34, 197, 94, 0.5);
            color: rgba(100, 230, 150, 0.95);
        }
        .hover-tooltip-id {
            font-weight: 700;
            font-size: 0.75rem;
            padding: 0.1rem 0.4rem;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.9);
        }
        .hover-tooltip-action {
            color: rgba(255, 255, 255, 0.3);
            font-size: 0.65rem;
            font-style: italic;
            padding-left: 0.4rem;
            border-left: 1px solid rgba(255, 255, 255, 0.1);
        }
        .hover-tooltip-name {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.8rem;
        }

        /* ONI closing text overlay (vector NI) */
        #oni-ni-overlay {
            position: fixed;
            pointer-events: none;
            z-index: 15;
            opacity: 0;
            font-family: 'Inter', Arial, sans-serif;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.88);
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.45), 0 0 60px rgba(255, 255, 255, 0.15);
            letter-spacing: 0.02em;
            white-space: nowrap;
            transform: translate(0, -50%);
            transform-origin: left center;
            line-height: 1;
        }

        /* Spring art overlay */
        #spring-art-overlay {
            position: fixed;
            pointer-events: none;
            z-index: 15;
            opacity: 0;
            font-family: 'Inter', Arial, sans-serif;
            color: rgba(255, 255, 255, 0.88);
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.25), 0 0 50px rgba(255, 255, 255, 0.08);
            white-space: nowrap;
            text-align: center;
            transform: translate(-50%, 0);
            line-height: 1.5;
        }
        .spring-art-title {
            font-weight: 200;
            font-size: 1.5rem;
            letter-spacing: 0.12em;
        }
        .spring-art-type {
            font-weight: 400;
            font-size: 0.65rem;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.4);
            margin-top: 0.35rem;
        }
        .spring-art-artist {
            font-weight: 400;
            font-size: 0.75rem;
            letter-spacing: 0.25em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 0.15rem;
        }

        /* Seizure warning */
        #seizure-warning {
            position: fixed;
            z-index: 20;
            pointer-events: none;
            opacity: 0;
            text-align: center;
            font-family: 'Inter', Arial, sans-serif;
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.5;
            transform: translate(-50%, -50%);
        }
        .seizure-warning-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }
        .seizure-warning-text {
            font-size: 0.95rem;
            font-weight: 500;
            letter-spacing: 0.05em;
        }
        /* Spring egg */
        #spring-egg {
            position: fixed;
            pointer-events: none;
            z-index: 16;
            font-size: 0;
            opacity: 0;
            transform: translate(-50%, -50%) scale(0);
            transition: none;
            filter: drop-shadow(0 0 12px rgba(255, 255, 255, 0.6)) drop-shadow(0 0 30px rgba(255, 200, 100, 0.3));
        }

        /* Floating layer label HUD */
        .layer-hud {
            position: fixed;
            bottom: 3rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.6rem 1.4rem;
            background: rgba(10, 15, 30, 0.7);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 100px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease, transform 0.4s ease;
        }

        .layer-hud.visible {
            opacity: 1;
        }

        .layer-hud-badge {
            display: inline-block;
            padding: 0.15rem 0.5rem;
            border-radius: 5px;
            font-size: 0.65rem;
            font-weight: 700;
            letter-spacing: 0.05em;
            flex-shrink: 0;
        }
        .layer-hud-badge.silicon { background: rgba(59,130,246,0.2); color: var(--accent-blue); }
        .layer-hud-badge.gateway { background: rgba(245,158,11,0.2); color: var(--accent-amber); }
        .layer-hud-badge.biology { background: rgba(16,185,129,0.2); color: var(--accent-green); }

        .layer-hud-name {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
        }

        .layer-hud-zone {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        /* Layer detail overlay (centered) */
        .layer-detail {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            text-align: center;
            max-width: 480px;
            padding: 2rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .layer-detail.visible {
            opacity: 1;
        }

        .layer-detail-tag {
            display: inline-block;
            font-size: 0.65rem;
            font-weight: 600;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            padding: 0.2rem 0.7rem;
            border-radius: 100px;
            margin-bottom: 1rem;
        }
        .layer-detail-tag.osi {
            background: rgba(59,130,246,0.12);
            color: var(--accent-blue);
            border: 1px solid rgba(59,130,246,0.25);
        }
        .layer-detail-tag.novel {
            background: rgba(139,92,246,0.12);
            color: var(--accent-purple);
            border: 1px solid rgba(139,92,246,0.25);
        }
        .layer-detail-tag.gateway-tag {
            background: rgba(245,158,11,0.12);
            color: var(--accent-amber);
            border: 1px solid rgba(245,158,11,0.25);
        }

        .layer-detail-desc {
            font-size: 1.05rem;
            line-height: 1.75;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
        }

        .layer-detail-context {
            font-size: 0.8rem;
            color: var(--text-muted);
            font-style: italic;
        }

        .layer-detail-formula {
            font-family: 'Inter', monospace;
            font-size: 1rem;
            color: var(--accent-amber);
            background: rgba(245, 158, 11, 0.08);
            border: 1px solid rgba(245, 158, 11, 0.2);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 0.75rem;
        }

        /* ============================================
           SCENE 4: THE PROOF
           ============================================ */
        #scene-proof {
            min-height: 100vh;
            padding: 8rem 0;
            position: relative;
            z-index: 1;
            background: linear-gradient(180deg,
                rgba(8, 12, 24, 0.8) 0%,
                rgba(8, 12, 24, 0.8) 50%,
                rgba(8, 12, 24, 0.8) 100%);
        }

        .proof-header {
            text-align: center;
            margin-bottom: 4rem;
        }

        .proof-header h2 {
            font-size: clamp(2rem, 3.5vw, 3rem);
            font-weight: 700;
            letter-spacing: -0.02em;
        }

        .proof-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3rem;
        }

        .proof-column h3 {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 1.5rem;
        }

        .researcher-card {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            padding: 1rem;
            border-radius: 10px;
            margin-bottom: 0.75rem;
            transition: background 0.2s;
        }

        .researcher-card:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        .researcher-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--bg-card);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            flex-shrink: 0;
            border: 1px solid var(--border);
        }

        .researcher-name {
            font-weight: 600;
            font-size: 0.95rem;
            margin-bottom: 0.15rem;
        }

        .researcher-inst {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-bottom: 0.25rem;
        }

        .researcher-contrib {
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        .proof-note {
            font-size: 0.85rem;
            color: var(--text-dim);
            font-style: italic;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }

        .regulatory-list {
            list-style: none;
        }

        .regulatory-list li {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            padding: 0.75rem 0;
            border-bottom: 1px solid rgba(30, 41, 59, 0.4);
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .regulatory-list li:last-child { border-bottom: none; }

        .check-icon {
            color: var(--accent-green);
            flex-shrink: 0;
            margin-top: 2px;
        }

        .regulatory-detail {
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        /* ============================================
           SCENE 5: QUOTE
           ============================================ */
        #scene-quote {
            min-height: 60vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            z-index: 1;
            padding: 4rem 2rem;
        }

        .quote-text {
            font-size: clamp(1.25rem, 3vw, 2.5rem);
            font-weight: 300;
            color: var(--text-secondary);
            text-align: center;
            max-width: 800px;
            line-height: 1.5;
            letter-spacing: -0.01em;
            transform: scale(0.85);
            opacity: 0.3;
        }

        .quote-author {
            text-align: center;
            margin-top: 1.5rem;
            font-size: 0.9rem;
            color: var(--text-dim);
            opacity: 0;
        }

        .quote-author a {
            color: var(--text-muted);
            text-decoration: none;
        }

        .quote-author a:hover { color: var(--text-secondary); }

        /* ============================================
           SCENE 6: WHAT'S BUILT
           ============================================ */
        #scene-built {
            padding: 8rem 0;
            position: relative;
            z-index: 1;
            background: linear-gradient(180deg,
                rgba(5, 10, 20, 0) 0%,
                rgba(8, 12, 24, 1) 30%,
                rgba(8, 12, 24, 1) 70%,
                rgba(5, 10, 20, 0) 100%);
        }

        .built-header {
            text-align: center;
            margin-bottom: 4rem;
        }

        .built-header h2 {
            font-size: clamp(2rem, 3.5vw, 3rem);
            font-weight: 700;
            letter-spacing: -0.02em;
        }

        .bento-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.25rem;
        }

        .bento-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 2rem;
            transition: all 0.3s;
            text-decoration: none;
            color: inherit;
            display: flex;
            flex-direction: column;
        }

        .bento-card:hover {
            border-color: rgba(59, 130, 246, 0.3);
            background: var(--bg-card-hover);
            transform: translateY(-4px);
            box-shadow: 0 16px 48px rgba(0, 0, 0, 0.3);
        }

        .bento-card .card-label {
            font-size: 0.7rem;
            font-weight: 600;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: var(--text-dim);
            margin-bottom: 0.75rem;
        }

        .bento-card h3 {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .bento-card .card-code {
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 0.8rem;
            color: var(--accent-cyan);
            background: rgba(6, 182, 212, 0.08);
            padding: 0.3rem 0.6rem;
            border-radius: 4px;
            display: inline-block;
            margin-bottom: 0.75rem;
        }

        .bento-card p {
            color: var(--text-muted);
            font-size: 0.875rem;
            line-height: 1.6;
            flex: 1;
        }

        .bento-card .card-link {
            color: var(--accent-blue);
            font-size: 0.85rem;
            font-weight: 500;
            margin-top: 1rem;
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
        }

        /* ============================================
           SCENE 7: VISION + CTA
           ============================================ */
        #scene-vision {
            min-height: 100vh;
            display: flex;
            align-items: center;
            padding: 8rem 0;
            position: relative;
            z-index: 1;
        }

        .vision-content {
            max-width: 860px;
            margin: 0 auto;
            text-align: center;
        }

        .vision-content h2 {
            font-size: clamp(1.75rem, 3vw, 2.75rem);
            font-weight: 700;
            letter-spacing: -0.02em;
            line-height: 1.25;
            margin-bottom: 2rem;
        }

        .vision-terminology {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem 2rem;
            text-align: left;
            margin-bottom: 2.5rem;
        }

        .vision-terminology h4 {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .vision-terminology p {
            font-size: 0.9rem;
            color: var(--text-muted);
            line-height: 1.6;
        }

        .vision-questions {
            text-align: left;
            margin-bottom: 3rem;
        }

        .vision-questions h4 {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .vision-questions ul {
            list-style: none;
        }

        .vision-questions li {
            color: var(--text-muted);
            font-size: 0.9rem;
            padding: 0.4rem 0;
            padding-left: 1.25rem;
            position: relative;
        }

        .vision-questions li::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--accent-blue);
            transform: translateY(-50%);
        }

        .vision-parallel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            margin-bottom: 3rem;
            text-align: left;
        }

        .parallel-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
        }

        .parallel-card .parallel-era {
            font-size: 0.7rem;
            font-weight: 700;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            margin-bottom: 0.5rem;
        }

        .parallel-card.then .parallel-era { color: var(--text-muted); }
        .parallel-card.now .parallel-era { color: var(--accent-amber); }

        .parallel-card h4 {
            font-size: 1.05rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .parallel-card p {
            font-size: 0.85rem;
            color: var(--text-muted);
            line-height: 1.6;
        }

        .parallel-card .parallel-result {
            margin-top: 0.75rem;
            font-size: 0.8rem;
            color: var(--accent-green);
            font-weight: 600;
        }

        .parallel-card.now .parallel-result {
            color: var(--accent-blue);
        }

        .vision-roadmap {
            text-align: left;
            margin-bottom: 3rem;
        }

        .vision-roadmap h4 {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 1.25rem;
            text-align: center;
        }

        .roadmap-timeline {
            position: relative;
            padding-left: 2rem;
        }

        .roadmap-timeline::before {
            content: '';
            position: absolute;
            left: 7px;
            top: 8px;
            bottom: 8px;
            width: 2px;
            background: linear-gradient(to bottom, var(--accent-blue), var(--accent-purple), var(--accent-amber));
            border-radius: 1px;
        }

        .roadmap-step {
            position: relative;
            padding-bottom: 1.5rem;
        }

        .roadmap-step:last-child {
            padding-bottom: 0;
        }

        .roadmap-step::before {
            content: '';
            position: absolute;
            left: -2rem;
            top: 6px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid var(--accent-blue);
            background: var(--bg-deep);
        }

        .roadmap-step.active::before {
            background: var(--accent-blue);
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.4);
        }

        .roadmap-step .step-label {
            font-size: 0.7rem;
            font-weight: 700;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--accent-blue);
            margin-bottom: 0.2rem;
        }

        .roadmap-step .step-title {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
        }

        .roadmap-step .step-desc {
            font-size: 0.8rem;
            color: var(--text-muted);
            line-height: 1.5;
        }

        .roadmap-step .step-body {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-dim);
            margin-top: 0.2rem;
        }

        @media (max-width: 768px) {
            .vision-parallel {
                grid-template-columns: 1fr;
            }
        }

        .cta-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.875rem 1.75rem;
            border-radius: 10px;
            font-weight: 600;
            font-size: 0.95rem;
            text-decoration: none;
            transition: all 0.3s;
            border: none;
            cursor: pointer;
        }

        .btn-primary {
            background: var(--accent-blue);
            color: white;
        }

        .btn-primary:hover {
            background: #2563eb;
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(59, 130, 246, 0.3);
        }

        .btn-secondary {
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            border-color: rgba(59, 130, 246, 0.4);
            color: var(--text-primary);
            background: rgba(59, 130, 246, 0.05);
        }

        /* ============================================
           FOOTER
           ============================================ */
        footer {
            padding: 3rem 2rem;
            text-align: center;
            border-top: 1px solid var(--border);
            position: relative;
            z-index: 1;
        }

        .footer-links {
            display: flex;
            gap: 2rem;
            justify-content: center;
            margin-bottom: 1rem;
        }

        .footer-links a {
            color: var(--text-muted);
            text-decoration: none;
            font-size: 0.85rem;
        }

        .footer-links a:hover { color: var(--text-secondary); }

        .footer-copy {
            color: var(--text-dim);
            font-size: 0.8rem;
        }

        #scene-tunnel {
            position: relative;
            z-index: 1;
        }
        .tunnel-scroll-space {
            height: 300vh;
        }

        /* ============================================
           RESPONSIVE
           ============================================ */
        @media (max-width: 1024px) {
            .layer-hud {
                bottom: 2rem;
                padding: 0.5rem 1.2rem;
            }
        }

        @media (max-width: 900px) {
            .problem-grid {
                grid-template-columns: 1fr;
                gap: 3rem;
            }
            .proof-grid {
                grid-template-columns: 1fr;
            }
            .bento-grid {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 600px) {
            .bento-grid {
                grid-template-columns: 1fr;
            }
            nav { padding: 0 1rem; }
            .scene-inner { padding: 0 1.25rem; }
        }

        /* ============================================
           ANIMATIONS
           ============================================ */
        .fade-up {
            opacity: 0;
            transform: translateY(30px);
        }

        .fade-in {
            opacity: 0;
        }
    </style>
</head>
<body>

    <!-- =============================================
         NAVIGATION
         ============================================= -->
    <nav id="main-nav">
        <div class="nav-inner">
            <a href="#" class="nav-logo">ONI</a>
            <ul class="nav-links">
                <li><a href="#scene-hero" data-section="scene-hero">Home</a></li>
                <li><a href="#scene-framework" data-section="scene-framework">Framework</a></li>
                <li><a href="#scene-proof" data-section="scene-proof">Research</a></li>
                <li><a href="visualizations/index.html">Tools</a></li>
                <li><a href="https://medium.com/@qikevinl" target="_blank" rel="noopener">Blog</a></li>
                <li>
                    <a href="https://github.com/qinnovates/mindloft" target="_blank" rel="noopener" class="nav-github" aria-label="GitHub">
                        <svg viewBox="0 0 16 16"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg>
                    </a>
                </li>
            </ul>
            <button class="nav-hamburger" onclick="toggleMobileMenu()" aria-label="Menu">
                <svg viewBox="0 0 24 24"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
            </button>
        </div>
    </nav>
    <div class="nav-mobile-menu" id="mobile-menu">
        <a href="#scene-hero" onclick="closeMobileMenu()">Home</a>
        <a href="#scene-framework" onclick="closeMobileMenu()">Framework</a>
        <a href="#scene-proof" onclick="closeMobileMenu()">Research</a>
        <a href="visualizations/index.html">Tools</a>
        <a href="https://medium.com/@qikevinl" target="_blank" rel="noopener">Blog</a>
        <a href="https://github.com/qinnovates/mindloft" target="_blank" rel="noopener">GitHub</a>
    </div>

    <!-- =============================================
         THREE.JS CANVAS (Fixed behind content)
         ============================================= -->
    <div id="three-canvas"></div>

    <!-- =============================================
         SCENE 1: HERO
         ============================================= -->
    <section id="scene-hero" class="scene">
        <div id="hero-osi-tagline-top" style="position: fixed; z-index: 2; text-align: center; top: 88%; left: 50%; transform: translate(-50%, -50%); width: 90%; max-width: 750px; opacity: 0;">
            <p id="hero-neuro-line" style="font-family: 'Inter', sans-serif; font-size: 1.2rem; font-weight: 700; letter-spacing: 0.3em; text-transform: uppercase; color: rgba(212,175,55,0.85); margin: 0; line-height: 1.8; opacity: 0; transform: translateY(15px); transition: opacity 1.2s ease-out, transform 1.2s ease-out;">Neurosecurity Standards for<br>Brain-Computer Interfaces</p>
            <p id="hero-osi-line" style="font-family: 'Inter', sans-serif; font-size: 1.6rem; letter-spacing: 0.35em; text-transform: uppercase; color: rgba(255,255,255,0.6); margin: 0.6rem 0 0 0; opacity: 0; transform: translateY(15px); transition: opacity 1.2s ease-out, transform 1.2s ease-out;">The OSI of Mind</p>
            <a id="hero-author-line" href="whitepaper/index.html" style="display: inline-block; font-family: 'Inter', sans-serif; font-size: 0.75rem; font-weight: 600; letter-spacing: 0.2em; text-transform: uppercase; color: rgba(212,175,55,0.9); text-decoration: none; border: 1px solid rgba(212,175,55,0.4); padding: 0.5rem 1.5rem; margin: 1rem 0 0 0; border-radius: 2rem; opacity: 0; transform: translateY(15px); transition: opacity 1.2s ease-out, transform 1.2s ease-out, border-color 0.3s, color 0.3s; animation: btnPulseGlow 2.5s ease-in-out infinite;" onmouseover="this.style.borderColor='rgba(212,175,55,0.8)';this.style.color='rgba(255,255,255,1)';" onmouseout="this.style.borderColor='rgba(212,175,55,0.4)';this.style.color='rgba(212,175,55,0.9)';">Read Whitepaper <span style="margin-left:0.3em;">&rarr;</span></a>
        </div>
        <div id="hero-quote-overlay" style="position: fixed; z-index: 2; text-align: center; top: 70%; left: 50%; transform: translate(-50%, -50%); width: 90%; max-width: 800px; opacity: 0; pointer-events: none;">
            <p style="font-family: 'SF Pro Display', 'Inter', -apple-system, sans-serif; font-size: clamp(1.3rem, 3vw, 2.2rem); font-weight: 300; font-style: italic; letter-spacing: 0.04em; color: rgba(255,255,255,0.85); margin: 0; line-height: 1.6;">The mind is the greatest frontier of our time.</p>
        </div>
        <div class="hero-scroll-indicator" id="scroll-indicator">
            <span class="hero-scroll-text">Scroll to explore the framework</span>
            <svg viewBox="0 0 24 24"><path d="M12 5v14M5 12l7 7 7-7"/></svg>
        </div>
    </section>

    <!-- OSI extension blurb — fades in as layers reveal on scroll -->
    <div id="osi-blurb" style="
        position: fixed;
        top: 50%;
        right: 6vw;
        transform: translateY(-50%);
        z-index: 3;
        text-align: left;
        max-width: 520px;
        padding: 0;
        opacity: 0;
        pointer-events: none;
        transition: none;
    ">
        <p style="
            font-family: 'SF Pro Display', 'Inter', -apple-system, sans-serif;
            font-size: clamp(2rem, 4vw, 3.5rem);
            font-weight: 600;
            line-height: 1.2;
            color: rgba(255,255,255,0.95);
            letter-spacing: -0.02em;
            margin: 0;
        ">Extending the classical OSI model into the bio-digital landscape.</p>
        <p style="
            font-family: 'SF Pro Display', 'Inter', -apple-system, sans-serif;
            font-size: clamp(1rem, 2vw, 1.4rem);
            font-weight: 400;
            line-height: 1.5;
            color: rgba(255,255,255,0.55);
            letter-spacing: 0;
            margin: 1.2rem 0 0 0;
        ">A unified standard built with <span style="color: #8b5cf6;">neurosecurity</span> and <span style="color: #06b6d4;">neuroethics</span> as its foundation.</p>
    </div>

    <!-- =============================================
         SCENE 2: THE PROBLEM
         ============================================= -->
    <section id="scene-problem" class="scene">
        <div class="scene-inner">
            <div class="problem-grid">
                <div class="problem-text">
                    <div class="section-label fade-up">The Problem</div>
                    <h2 class="fade-up">BCIs are here.<br>Security standards aren't.</h2>
                    <p class="fade-up">244,000+ patients have wirelessly accessible deep brain implants &mdash; and researchers have shown their communications are neither encrypted nor authenticated. Foundational researchers &mdash; Kohno, Bonaci, Yuste, Ienca &mdash; identified threats over a decade ago. But no unified, implementable framework exists. ONI fills that gap.</p>
                    <p class="fade-up" style="margin-top: 1rem; font-size: 0.95rem; opacity: 0.7;">The OSI model gave computer networks a universal security architecture in 1984 &mdash; fourteen years before Google existed. BCI technology is already in patients&rsquo; brains, and it still has nothing equivalent.</p>
                </div>
                <div class="problem-stats">
                    <div class="stat-item">
                        <div class="stat-number blue" data-target="6.5" data-prefix="$" data-suffix="B">$0</div>
                        <div class="stat-desc">BCI market by 2030</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-number amber" data-target="244" data-suffix="K+">0</div>
                        <div class="stat-desc">Patients with deep brain implants</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-number red" data-target="0" data-static="true">0</div>
                        <div class="stat-desc">BCI-specific security standards</div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- =============================================
         SCENE 3: THE FRAMEWORK (Scroll-driven 3D)
         ============================================= -->
    <section id="scene-framework" class="scene">
        <div class="framework-scroll-track">
            <!-- Intro trigger -->
            <div class="framework-intro-trigger" data-zone="all"></div>

            <!-- Interactive zone: click layers to explore -->
            <div class="framework-interactive-zone"></div>

            <!-- Closing trigger -->
            <div class="framework-closing-trigger" data-zone="all"></div>
        </div>
    </section>

    <!-- Layer detail overlay (centered) -->
    <div class="layer-detail" id="layer-detail">
        <div class="layer-detail-tag" id="layer-detail-tag"></div>
        <p class="layer-detail-desc" id="layer-detail-desc"></p>
        <p class="layer-detail-context" id="layer-detail-context"></p>
        <div class="layer-detail-formula" id="layer-detail-formula" style="display:none;"></div>
    </div>

    <!-- Click-to-explore hint -->
    <div class="click-hint" id="click-hint">
        <div class="click-hint-icon">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M15 15l-2 5L9 9l11 4-5 2z"/>
                <path d="M21 21l-4.35-4.35"/>
            </svg>
        </div>
        <span>Click any layer to explore</span>
    </div>

    <!-- Hover tooltip (follows cursor) -->
    <div class="hover-tooltip" id="hover-tooltip">
        <span class="hover-tooltip-zone"></span>
        <span class="hover-tooltip-id"></span>
        <span class="hover-tooltip-name"></span>
        <span class="hover-tooltip-action">Click to expand</span>
    </div>

    <!-- ONI closing text: vector NI overlay -->
    <div id="oni-ni-overlay">NI</div>

    <!-- Seizure warning prompt -->
    <div id="seizure-warning">
        <div class="seizure-warning-icon">&#x26A0;</div>
        <div class="seizure-warning-text">Photosensitivity Warning</div>
    </div>

    <!-- Spring art mode: title + artist overlay -->
    <div id="spring-art-overlay">
        <div class="spring-art-title">&ldquo;Spatial Synesthesia&rdquo;</div>
        <div class="spring-art-type">Digital Light Art</div>
        <div class="spring-art-artist">Kevin L. Qi</div>
    </div>

    <!-- Spring egg: literal easter egg from L14 center -->
    <div id="spring-egg">&#x1F95A;</div>

    <!-- Easter egg: heart + thank you message -->
    <div id="easter-egg-overlay" class="easter-egg-overlay">
        <div class="easter-egg-content">
            <div class="easter-egg-heart" id="easter-egg-heart">
                <svg viewBox="0 0 100 90" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M50 85 C25 65 0 45 0 25 C0 10 12 0 25 0 C35 0 45 8 50 15 C55 8 65 0 75 0 C88 0 100 10 100 25 C100 45 75 65 50 85Z" fill="url(#heartGrad)" stroke="rgba(255,255,255,0.3)" stroke-width="0.5"/>
                    <defs>
                        <radialGradient id="heartGrad" cx="50%" cy="40%" r="60%">
                            <stop offset="0%" stop-color="#ff6b9d"/>
                            <stop offset="60%" stop-color="#ec4899"/>
                            <stop offset="100%" stop-color="#be185d"/>
                        </radialGradient>
                    </defs>
                </svg>
            </div>
            <p class="easter-egg-text" id="easter-egg-text">placeholder</p>
            <button class="easter-egg-close" id="easter-egg-close">&times;</button>
        </div>
    </div>

    <!-- Layer HUD (floating label) -->
    <div class="layer-hud" id="layer-hud">
        <span class="layer-hud-badge" id="layer-hud-badge"></span>
        <span class="layer-hud-name" id="layer-hud-name"></span>
        <span class="layer-hud-zone" id="layer-hud-zone"></span>
    </div>

    <!-- =============================================
         SCENE 4: THE PROOF
         ============================================= -->
    <section id="scene-proof" class="scene">
        <div class="scene-inner">
            <div class="proof-header">
                <div class="section-label fade-up">Foundations</div>
                <h2 class="fade-up">Built on a decade of research.</h2>
            </div>
            <div class="proof-grid">
                <!-- Research Column -->
                <div class="proof-column fade-up">
                    <h3>Research Foundations</h3>

                    <div class="researcher-card">
                        <div class="researcher-avatar">TK</div>
                        <div>
                            <div class="researcher-name">Tadayoshi Kohno</div>
                            <div class="researcher-inst">University of Washington</div>
                            <div class="researcher-contrib">BCI threat modeling &amp; security analysis</div>
                        </div>
                    </div>

                    <div class="researcher-card">
                        <div class="researcher-avatar">TB</div>
                        <div>
                            <div class="researcher-name">Tamara Bonaci</div>
                            <div class="researcher-inst">University of Washington</div>
                            <div class="researcher-contrib">Neural signal attack demonstration</div>
                        </div>
                    </div>

                    <div class="researcher-card">
                        <div class="researcher-avatar">RY</div>
                        <div>
                            <div class="researcher-name">Rafael Yuste</div>
                            <div class="researcher-inst">Columbia University</div>
                            <div class="researcher-contrib">Neurorights framework</div>
                        </div>
                    </div>

                    <div class="researcher-card">
                        <div class="researcher-avatar">MI</div>
                        <div>
                            <div class="researcher-name">Marcello Ienca</div>
                            <div class="researcher-inst">ETH Zurich / TU Munich</div>
                            <div class="researcher-contrib">Four neurorights framework</div>
                        </div>
                    </div>

                    <div class="researcher-card">
                        <div class="researcher-avatar">GL</div>
                        <div>
                            <div class="researcher-name">Gabriel L&aacute;zaro-Mu&ntilde;oz</div>
                            <div class="researcher-inst">Harvard Law School</div>
                            <div class="researcher-contrib">Informed consent for neural devices</div>
                        </div>
                    </div>

                    <p class="proof-note">ONI extends foundational BCI security research into a unified, implementable architecture.</p>
                </div>

                <!-- Regulatory Column -->
                <div class="proof-column fade-up">
                    <h3>Regulatory Alignment</h3>
                    <ul class="regulatory-list">
                        <li>
                            <span class="check-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20 6 9 17 4 12"/></svg></span>
                            <div>
                                UNESCO Recommendation on Neurotechnology (2025)
                                <div class="regulatory-detail">15 of 17 elements implemented</div>
                            </div>
                        </li>
                        <li>
                            <span class="check-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20 6 9 17 4 12"/></svg></span>
                            <div>
                                US MIND Act (S. 2925)
                                <div class="regulatory-detail">Federal neurotechnology legislation</div>
                            </div>
                        </li>
                        <li>
                            <span class="check-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20 6 9 17 4 12"/></svg></span>
                            <div>
                                4 State Neurorights Laws
                                <div class="regulatory-detail">Colorado, California, Montana, Connecticut</div>
                            </div>
                        </li>
                        <li>
                            <span class="check-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20 6 9 17 4 12"/></svg></span>
                            <div>
                                FDA Cybersecurity Guidance (2023)
                                <div class="regulatory-detail">Medical device security requirements</div>
                            </div>
                        </li>
                        <li>
                            <span class="check-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20 6 9 17 4 12"/></svg></span>
                            <div>
                                9 Governance Documents Published
                                <div class="regulatory-detail">Ethics, consent, accessibility, data policy</div>
                            </div>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </section>

    <!-- =============================================
         SCENE 5: QUOTE
         ============================================= -->
    <section id="scene-quote" class="scene">
        <div>
            <p class="quote-text" id="quote-text">"Only life's most important connections deserve the most thought."</p>
            <p class="quote-author" id="quote-author">&mdash; Kevin Qi</p>
        </div>
    </section>

    <!-- =============================================
         SCENE 6: WHAT'S BUILT
         ============================================= -->
    <section id="scene-built" class="scene">
        <div class="scene-inner">
            <div class="built-header">
                <div class="section-label fade-up">Ecosystem</div>
                <h2 class="fade-up">What's been built.</h2>
            </div>
            <div class="bento-grid">
                <a href="https://pypi.org/project/oni-framework/" target="_blank" rel="noopener" class="bento-card fade-up">
                    <div class="card-label">Python Package</div>
                    <h3>ONI Framework</h3>
                    <div class="card-code">pip install oni-framework</div>
                    <p>14-layer model, coherence metric, scale-frequency invariant. The core library.</p>
                    <span class="card-link">PyPI &rarr;</span>
                </a>

                <a href="https://pypi.org/project/oni-tara/" target="_blank" rel="noopener" class="bento-card fade-up">
                    <div class="card-label">Security Stack</div>
                    <h3>TARA Stack</h3>
                    <div class="card-code">pip install oni-tara</div>
                    <p>Attack simulation, signal analysis, neural firewall prototype. Named after the Buddhist goddess of protection.</p>
                    <span class="card-link">PyPI &rarr;</span>
                </a>

                <a href="visualizations/index.html" class="bento-card fade-up">
                    <div class="card-label">Web Applications</div>
                    <h3>Interactive Tools</h3>
                    <p>10 web apps: coherence playground, threat matrix, layer explorer, framework visualization, and more.</p>
                    <span class="card-link">Explore &rarr;</span>
                </a>

                <a href="whitepaper/index.html" class="bento-card fade-up">
                    <div class="card-label">Research</div>
                    <h3>Whitepaper</h3>
                    <p>Complete framework overview, market analysis, regulatory mapping, and technical architecture.</p>
                    <span class="card-link">Read &rarr;</span>
                </a>

                <a href="documentation/index.html" class="bento-card fade-up">
                    <div class="card-label">Documentation</div>
                    <h3>20+ Publications</h3>
                    <p>Technical documents and blog posts across 8 research areas. Detection theory, quantum encryption, neural ransomware, and more.</p>
                    <span class="card-link">Browse &rarr;</span>
                </a>

                <a href="https://github.com/qinnovates/mindloft" target="_blank" rel="noopener" class="bento-card fade-up">
                    <div class="card-label">Open Source</div>
                    <h3>Apache 2.0</h3>
                    <p>Full transparency audit. Reproducible research. Human-AI collaboration documented in governance.</p>
                    <span class="card-link">GitHub &rarr;</span>
                </a>
            </div>
        </div>
    </section>

    <!-- =============================================
         SCENE 7: VISION + CTA
         ============================================= -->
    <section id="scene-vision" class="scene">
        <div class="scene-inner">
            <div class="vision-content">
                <div class="section-label fade-up">Vision</div>
                <h2 class="fade-up">Standardization unlocked the internet.<br>The brain is still waiting.</h2>

                <!-- Historical Parallel -->
                <div class="vision-parallel fade-up">
                    <div class="parallel-card then">
                        <div class="parallel-era">1970s &ndash; 1980s</div>
                        <h4>Before OSI</h4>
                        <p>Every manufacturer had proprietary networking protocols. Nothing could talk to anything else. No interoperability, no security baselines, no shared language.</p>
                        <div class="parallel-result">Then came OSI, TCP/IP, IEEE 802 &rarr; the internet.</div>
                    </div>
                    <div class="parallel-card now">
                        <div class="parallel-era">Today</div>
                        <h4>Before neurosecurity standards</h4>
                        <p>Every BCI manufacturer builds proprietary signal processing. No shared security model. No interoperability standards. No ethical baselines for neural data.</p>
                        <div class="parallel-result">ONI is the draft that formal standards bodies can adopt.</div>
                    </div>
                </div>

                <div class="vision-terminology fade-up">
                    <h4>The Advantage We Have Now</h4>
                    <p>When OSI was created, cybersecurity was a narrow government concern &mdash; not a design consideration. Encryption was classified as munitions. Firewalls hadn't been invented. The internet was built first &mdash; then spent decades retrofitting security after the damage was done. We don't have that excuse. We have 40+ years of hard-won security lessons, battle-tested frameworks, proven cryptography, and entire disciplines built on protecting data in transit. ONI takes everything the security industry has learned and bakes it into the neural standard <em>from the start</em> &mdash; so we don't repeat the same mistake with the most important network of all.</p>
                </div>

                <div class="vision-terminology fade-up">
                    <h4>Why &ldquo;Neurosecurity&rdquo;</h4>
                    <p>Foundational researchers established &ldquo;BCI security&rdquo; as the discipline. ONI adopts <em>neurosecurity</em> &mdash; protecting the neural system itself, regardless of what interfaces with it. The scope is broader: not just the interface, but everything it connects to.</p>
                </div>

                <!-- Roadmap -->
                <div class="vision-roadmap fade-up">
                    <h4>Roadmap to Formal Standardization</h4>
                    <div class="roadmap-timeline">
                        <div class="roadmap-step active">
                            <div class="step-label">Current</div>
                            <div class="step-title">Open Framework &amp; Research</div>
                            <div class="step-desc">14-layer model, coherence metric, 46 threat signatures, 9 governance documents. Open source, peer-reviewable, Apache 2.0.</div>
                        </div>
                        <div class="roadmap-step">
                            <div class="step-label">Next</div>
                            <div class="step-title">Academic Validation &amp; Collaboration</div>
                            <div class="step-desc">Partner with BCI security researchers and neuroscience labs to validate layers, refine threat models, and test the coherence metric against real neural data.</div>
                        </div>
                        <div class="roadmap-step">
                            <div class="step-label">IEEE</div>
                            <div class="step-title">Technical Standard Proposal</div>
                            <div class="step-desc">Submit ONI's technical layers (signal security, transport integrity, gateway coherence) as a proposal to IEEE &mdash; like IEEE 802 standardized wireless networking.</div>
                            <div class="step-body">Target: IEEE Standards Association &mdash; Neurotechnology Working Group</div>
                        </div>
                        <div class="roadmap-step">
                            <div class="step-label">ISO / IEC</div>
                            <div class="step-title">Governance &amp; Compliance Framework</div>
                            <div class="step-desc">Propose ONI's governance layers (neuroethics alignment, informed consent, data policy) as an ISO/IEC standard &mdash; like ISO 27001 for information security.</div>
                            <div class="step-body">Target: ISO/IEC JTC 1 &mdash; Information Security &amp; Emerging Technologies</div>
                        </div>
                        <div class="roadmap-step">
                            <div class="step-label">Long-Term</div>
                            <div class="step-title">Dedicated Neurotechnology Standards Body</div>
                            <div class="step-desc">UNESCO's 2025 Recommendation on Neurotechnology calls for a dedicated standards body. ONI is designed to be the technical foundation it can build on.</div>
                        </div>
                    </div>
                </div>

                <div class="vision-questions fade-up">
                    <h4>Open Research Questions</h4>
                    <ul>
                        <li>Can coherence-based detection achieve clinical-grade sensitivity?</li>
                        <li>How do quantum key distribution protocols adapt to neural bandwidth constraints?</li>
                        <li>What governance models protect cognitive liberty while enabling therapeutic benefit?</li>
                    </ul>
                </div>

                <div class="cta-buttons fade-up">
                    <a href="whitepaper/index.html" class="btn btn-primary">Read the Whitepaper</a>
                    <a href="https://github.com/qinnovates/mindloft" target="_blank" rel="noopener" class="btn btn-secondary">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg>
                        Star on GitHub
                    </a>
                    <a href="documentation/index.html" class="btn btn-secondary">View Documentation</a>
                </div>
            </div>
        </div>
    </section>

    <!-- =============================================
         SCENE 8: TUNNEL / SLINKY INTO THE ABYSS
         ============================================= -->
    <section id="scene-tunnel">
        <div class="tunnel-scroll-space"></div>
    </section>

    <!-- =============================================
         FOOTER
         ============================================= -->
    <footer>
        <div class="footer-links">
            <a href="https://github.com/qinnovates/mindloft/blob/main/ABOUT.md" target="_blank" rel="noopener">About</a>
            <a href="https://github.com/qinnovates/mindloft" target="_blank" rel="noopener">GitHub</a>
            <a href="https://pypi.org/project/oni-framework/" target="_blank" rel="noopener">PyPI</a>
            <a href="https://medium.com/@qikevinl" target="_blank" rel="noopener">Medium</a>
        </div>
        <p class="footer-copy">&copy; 2026 Kevin Qi &amp; Qinnovate LLC. All rights reserved.</p>
        <p class="footer-copy" style="margin-top: 0.4rem; font-size: 0.7rem; color: var(--text-dim);">
            Website design, animations, and visual assets are proprietary. The ONI Framework research is licensed under Apache 2.0.
        </p>
    </footer>

    <!-- =============================================
         JAVASCRIPT
         ============================================= -->
    <script>
    (function() {
        'use strict';

        // =============================================
        // NAVIGATION
        // =============================================
        var mainNav = document.getElementById('main-nav');

        window.addEventListener('scroll', function() {
            if (window.scrollY > 50) {
                mainNav.classList.add('scrolled');
            } else {
                mainNav.classList.remove('scrolled');
            }
        });

        // Scroll spy
        var navLinks = document.querySelectorAll('.nav-links a[data-section]');
        var sections = document.querySelectorAll('.scene[id]');

        function updateScrollSpy() {
            var scrollPos = window.scrollY + 200;
            sections.forEach(function(section) {
                var top = section.offsetTop;
                var bottom = top + section.offsetHeight;
                var id = section.id;
                navLinks.forEach(function(link) {
                    if (link.dataset.section === id) {
                        if (scrollPos >= top && scrollPos < bottom) {
                            link.classList.add('active');
                        } else {
                            link.classList.remove('active');
                        }
                    }
                });
            });
        }
        window.addEventListener('scroll', updateScrollSpy);

        // Mobile menu
        window.toggleMobileMenu = function() {
            document.getElementById('mobile-menu').classList.toggle('open');
        };
        window.closeMobileMenu = function() {
            document.getElementById('mobile-menu').classList.remove('open');
        };

        // =============================================
        // HERO TEXT ANIMATION
        // =============================================
        gsap.set('#scroll-indicator', { opacity: 1 });

        gsap.to('#scroll-indicator', {
            scrollTrigger: {
                trigger: '#scene-hero',
                start: '20% top',
                end: '40% top',
                scrub: 1
            },
            opacity: 0
        });

        // OSI blurb: driven by rawMorph in animation loop (see osiBlurbEl below)

        // =============================================
        // FADE-UP ANIMATIONS (GSAP ScrollTrigger)
        // =============================================
        gsap.utils.toArray('.fade-up').forEach(function(el) {
            gsap.to(el, {
                scrollTrigger: {
                    trigger: el,
                    start: 'top 85%',
                    toggleActions: 'play none none none'
                },
                opacity: 1,
                y: 0,
                duration: 0.8,
                ease: 'power2.out'
            });
        });

        // =============================================
        // SCENE 2: STAT COUNTERS
        // =============================================
        document.querySelectorAll('.stat-item').forEach(function(item, i) {
            gsap.to(item, {
                scrollTrigger: {
                    trigger: item,
                    start: 'top 85%',
                    toggleActions: 'play none none none'
                },
                opacity: 1,
                x: 0,
                duration: 0.7,
                delay: i * 0.2,
                ease: 'power2.out',
                onStart: function() {
                    var numEl = item.querySelector('.stat-number');
                    if (!numEl || numEl.dataset.animated) return;
                    numEl.dataset.animated = '1';

                    var target = parseFloat(numEl.dataset.target);
                    var prefix = numEl.dataset.prefix || '';
                    var suffix = numEl.dataset.suffix || '';
                    var isStatic = numEl.dataset.static === 'true';

                    if (isStatic) {
                        numEl.textContent = prefix + target + suffix;
                        return;
                    }

                    var obj = { val: 0 };
                    gsap.to(obj, {
                        val: target,
                        duration: 1.5,
                        ease: 'power2.out',
                        onUpdate: function() {
                            if (target % 1 !== 0) {
                                numEl.textContent = prefix + obj.val.toFixed(1) + suffix;
                            } else {
                                numEl.textContent = prefix + Math.round(obj.val) + suffix;
                            }
                        }
                    });
                }
            });
        });

        // =============================================
        // SCENE 5: QUOTE SCROLL-SCALE
        // =============================================
        gsap.to('#quote-text', {
            scrollTrigger: {
                trigger: '#scene-quote',
                start: 'top 80%',
                end: 'center center',
                scrub: 1
            },
            scale: 1,
            opacity: 1,
            ease: 'power2.out'
        });

        gsap.to('#quote-author', {
            scrollTrigger: {
                trigger: '#scene-quote',
                start: 'center 60%',
                end: 'center 40%',
                scrub: 1
            },
            opacity: 1
        });

        // =============================================
        // THREE.JS: HERO CONCENTRIC SPHERES
        // =============================================
        var threeContainer = document.getElementById('three-canvas');
        if (threeContainer && typeof THREE !== 'undefined') {
            initHero3D();
        }

        function initHero3D() {
            var isMobile = window.innerWidth <= 768;
            var isTablet = window.innerWidth <= 1024;
            var osiBlurbEl = document.getElementById('osi-blurb');

            // Renderer
            var renderer = new THREE.WebGLRenderer({
                alpha: true,
                antialias: !isMobile,
                powerPreference: 'high-performance'
            });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x050a14, 1);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            threeContainer.appendChild(renderer.domElement);

            // Scene & Camera
            var scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050a14, 0.035);
            var camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.07, 7.87);

            // Groups
            var autoRotateGroup = new THREE.Group();
            var parallaxGroup = new THREE.Group();
            scene.add(autoRotateGroup);
            autoRotateGroup.add(parallaxGroup);
            autoRotateGroup.position.y = 0.5;

            // Lighting
            scene.add(new THREE.AmbientLight(0x1a2744, 0.3));
            var keyLight = new THREE.PointLight(0x3b82f6, 2.0, 25);
            keyLight.position.set(4, 3, 5);
            scene.add(keyLight);
            var fillLight = new THREE.PointLight(0x8b5cf6, 1.2, 20);
            fillLight.position.set(-3, -2, 3);
            scene.add(fillLight);
            var rimLight = new THREE.PointLight(0x06b6d4, 1.5, 20);
            rimLight.position.set(0, 1, -5);
            scene.add(rimLight);
            var gatewayLight = new THREE.PointLight(0x1a8cb3, 1.0, 12);
            gatewayLight.position.set(0, 0, 3);
            scene.add(gatewayLight);

            // Fresnel Shader (with outer glow + electric pool effect)
            var fresnelVert = [
                'varying vec3 vNormal;',
                'varying vec3 vViewPos;',
                'varying vec3 vWorldPos;',
                'void main() {',
                '  vNormal = normalize(normalMatrix * normal);',
                '  vec4 mv = modelViewMatrix * vec4(position, 1.0);',
                '  vViewPos = -mv.xyz;',
                '  vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;',
                '  gl_Position = projectionMatrix * mv;',
                '}'
            ].join('\n');

            var fresnelFrag = [
                'uniform vec3 uColor;',
                'uniform float uOpacity;',
                'uniform float uFresnelPower;',
                'uniform float uGlowIntensity;',
                'uniform float uTime;',
                'uniform float uActiveGlow;',
                'varying vec3 vNormal;',
                'varying vec3 vViewPos;',
                'varying vec3 vWorldPos;',
                'void main() {',
                '  vec3 vd = normalize(vViewPos);',
                '  float fresnel = pow(1.0 - abs(dot(vd, vNormal)), uFresnelPower);',
                '  float shimmer = 1.0 + 0.08 * sin(uTime * 2.0 + vNormal.x * 12.0);',
                '',
                '  // Calm electric pool ripple (when active)',
                '  float ripple1 = sin(vWorldPos.x * 4.0 + uTime * 0.8) * cos(vWorldPos.z * 3.5 + uTime * 0.6);',
                '  float ripple2 = sin(vWorldPos.x * 6.0 - uTime * 0.5 + 1.7) * cos(vWorldPos.z * 5.0 + uTime * 0.4);',
                '  float poolEffect = 0.5 + 0.3 * ripple1 + 0.2 * ripple2;',
                '  float electricPool = mix(1.0, poolEffect * 1.4 + 0.3, uActiveGlow);',
                '',
                '  // White outer glow (edge bloom)',
                '  float outerGlow = pow(fresnel, 1.2) * uActiveGlow;',
                '  vec3 glowColor = mix(uColor, vec3(1.0), outerGlow * 0.6);',
                '',
                '  float alpha = fresnel * uOpacity * shimmer * electricPool;',
                '  alpha += outerGlow * 0.35;',
                '  vec3 col = glowColor * (1.0 + fresnel * uGlowIntensity + outerGlow * 1.5);',
                '',
                '  gl_FragColor = vec4(col, alpha);',
                '}'
            ].join('\n');

            // Blend shader — mix of standard fresnel + bubble thin-film (uBubbleMix controls ratio)
            var blendFrag = [
                'uniform vec3 uColor;',
                'uniform float uOpacity;',
                'uniform float uFresnelPower;',
                'uniform float uGlowIntensity;',
                'uniform float uTime;',
                'uniform float uActiveGlow;',
                'uniform float uBubbleMix;',
                'varying vec3 vNormal;',
                'varying vec3 vViewPos;',
                'varying vec3 vWorldPos;',
                'void main() {',
                '  vec3 vd = normalize(vViewPos);',
                '  float NdotV = abs(dot(vd, vNormal));',
                '  float fresnel = pow(1.0 - NdotV, uFresnelPower);',
                '  float shimmer = 1.0 + 0.08 * sin(uTime * 2.0 + vNormal.x * 12.0);',
                '',
                '  // Standard fresnel path',
                '  float ripple1 = sin(vWorldPos.x * 4.0 + uTime * 0.8) * cos(vWorldPos.z * 3.5 + uTime * 0.6);',
                '  float ripple2 = sin(vWorldPos.x * 6.0 - uTime * 0.5 + 1.7) * cos(vWorldPos.z * 5.0 + uTime * 0.4);',
                '  float poolEffect = 0.5 + 0.3 * ripple1 + 0.2 * ripple2;',
                '  float electricPool = mix(1.0, poolEffect * 1.4 + 0.3, uActiveGlow);',
                '  float outerGlow = pow(fresnel, 1.2) * uActiveGlow;',
                '  vec3 stdColor = mix(uColor, vec3(1.0), outerGlow * 0.6);',
                '  float stdAlpha = fresnel * uOpacity * shimmer * electricPool + outerGlow * 0.35;',
                '  vec3 stdCol = stdColor * (1.0 + fresnel * uGlowIntensity + outerGlow * 1.5);',
                '',
                '  // Bubble thin-film path',
                '  float thickness = NdotV * 2.5',
                '    + sin(vWorldPos.x * 3.0 + vWorldPos.z * 2.0 + uTime * 0.2) * 0.3',
                '    + sin(vWorldPos.y * 4.0 - vWorldPos.x * 1.5 + uTime * 0.15) * 0.2;',
                '  float filmR = 0.5 + 0.5 * cos(thickness * 6.2832 * 1.0);',
                '  float filmG = 0.5 + 0.5 * cos(thickness * 6.2832 * 1.15 + 1.2);',
                '  float filmB = 0.5 + 0.5 * cos(thickness * 6.2832 * 1.35 + 2.5);',
                '  vec3 filmColor = vec3(filmR, filmG, filmB);',
                '  float iriStrength = 0.3 + fresnel * 0.7;',
                '  vec3 bubbleCol = mix(uColor * 0.4, filmColor, iriStrength);',
                '  float rim = pow(fresnel, 2.0);',
                '  bubbleCol += mix(filmColor, vec3(1.0), 0.5) * rim * 0.6;',
                '  float bubbleAlpha = rim * 0.5 + (1.0 - fresnel) * 0.08 + fresnel * 0.35 * uOpacity;',
                '',
                '  // Purple inner glow (scales with bubbleMix — strongest on L14)',
                '  float purplePulse = 0.5 + 0.5 * sin(uTime * 0.5 + vWorldPos.y * 2.0);',
                '  vec3 purpleGlow = vec3(0.85, 0.15, 0.95) * purplePulse * (1.0 - fresnel) * uBubbleMix * 1.4;',
                '  bubbleCol += purpleGlow;',
                '',
                '  // White core glow (bright center, fades to edges)',
                '  float coreGlow = pow(NdotV, 3.0) * uBubbleMix * 0.35;',
                '  bubbleCol += vec3(1.0) * coreGlow;',
                '  bubbleAlpha += coreGlow * 0.3;',
                '',
                '  // White outer rim glow (bright edge bloom, strongest on L14)',
                '  float outerRim = pow(fresnel, 1.5) * uBubbleMix * 0.7;',
                '  bubbleCol += vec3(1.0) * outerRim;',
                '  bubbleAlpha += outerRim * 0.5;',
                '',
                '  // Blend by uBubbleMix',
                '  vec3 col = mix(stdCol, bubbleCol, uBubbleMix);',
                '  float alpha = mix(stdAlpha, bubbleAlpha, uBubbleMix);',
                '',
                '  gl_FragColor = vec4(col, alpha);',
                '}'
            ].join('\n');

            // L14 Identity Shader — soap bubble: translucent with thin-film interference
            var identityFrag = [
                'uniform vec3 uColor;',
                'uniform float uOpacity;',
                'uniform float uTime;',
                'uniform float uActiveGlow;',
                'uniform float uGlowIntensity;',
                'varying vec3 vNormal;',
                'varying vec3 vViewPos;',
                'varying vec3 vWorldPos;',
                'void main() {',
                '  vec3 vd = normalize(vViewPos);',
                '  float NdotV = abs(dot(vd, vNormal));',
                '  float fresnel = pow(1.0 - NdotV, 3.0);',
                '',
                '  // Thin-film interference: bubble-like scattered light',
                '  // Film thickness varies across surface (like soap)',
                '  float thickness = NdotV * 2.5',
                '    + sin(vWorldPos.x * 3.0 + vWorldPos.z * 2.0 + uTime * 0.2) * 0.3',
                '    + sin(vWorldPos.y * 4.0 - vWorldPos.x * 1.5 + uTime * 0.15) * 0.2;',
                '',
                '  // Interference colors: each RGB channel has different period',
                '  float filmR = 0.5 + 0.5 * cos(thickness * 6.2832 * 1.0 + 0.0);',
                '  float filmG = 0.5 + 0.5 * cos(thickness * 6.2832 * 1.15 + 1.2);',
                '  float filmB = 0.5 + 0.5 * cos(thickness * 6.2832 * 1.35 + 2.5);',
                '  vec3 filmColor = vec3(filmR, filmG, filmB);',
                '',
                '  // Stronger interference at glancing angles (like a real bubble)',
                '  float iriStrength = 0.3 + fresnel * 0.7;',
                '  vec3 bubbleCol = mix(uColor * 0.4, filmColor, iriStrength);',
                '',
                '  // Gentle heartbeat — subtle brightness pulse',
                '  float heartCycle = mod(uTime * 0.7, 6.2832);',
                '  float lub = exp(-8.0 * pow(heartCycle - 1.0, 2.0));',
                '  float dub = exp(-10.0 * pow(heartCycle - 1.6, 2.0));',
                '  float heartbeat = (lub + dub * 0.7) * 0.3;',
                '',
                '  // Bubble edge: bright rim like light catching the membrane',
                '  float rim = pow(fresnel, 2.0);',
                '  vec3 rimColor = mix(filmColor, vec3(1.0), 0.5);',
                '  bubbleCol += rimColor * rim * 0.6;',
                '',
                '  // Interior: mostly transparent, faint scattered color visible through',
                '  float interior = (1.0 - fresnel) * 0.08 * (1.0 + heartbeat);',
                '',
                '  // Translucent alpha: thin at center, visible at edges',
                '  float alpha = rim * 0.5 + interior + fresnel * 0.35 * uOpacity;',
                '  alpha *= (0.85 + heartbeat * 0.15);',
                '  alpha += uActiveGlow * rim * 0.2;',
                '',
                '  // Boost color brightness at rim',
                '  bubbleCol *= (1.0 + rim * uGlowIntensity * 0.3 + heartbeat * 0.2);',
                '',
                '  gl_FragColor = vec4(bubbleCol, alpha);',
                '}'
            ].join('\n');

            // Gateway Shader (with outer glow + electric pool effect)
            var gatewayFrag = [
                'uniform vec3 uColor;',
                'uniform float uOpacity;',
                'uniform float uTime;',
                'uniform float uActiveGlow;',
                'varying vec3 vNormal;',
                'varying vec3 vViewPos;',
                'varying vec3 vWorldPos;',
                'void main() {',
                '  vec3 vd = normalize(vViewPos);',
                '  float fresnel = pow(1.0 - abs(dot(vd, vNormal)), 2.5);',
                '  float pulse = 0.6 + 0.4 * sin(uTime * 3.0);',
                '  float energy = fresnel * pulse;',
                '  float scan = 0.5 + 0.5 * sin(vNormal.y * 20.0 + uTime * 4.0);',
                '  energy += scan * 0.15 * fresnel;',
                '',
                '  // Calm electric pool (gateway version — warmer, slower)',
                '  float ripple1 = sin(vWorldPos.x * 3.0 + uTime * 0.6) * cos(vWorldPos.z * 2.5 + uTime * 0.4);',
                '  float ripple2 = sin(vWorldPos.x * 5.0 - uTime * 0.35 + 2.1) * cos(vWorldPos.z * 4.0 + uTime * 0.3);',
                '  float poolEffect = 0.5 + 0.3 * ripple1 + 0.2 * ripple2;',
                '  float electricPool = mix(1.0, poolEffect * 1.6 + 0.2, uActiveGlow);',
                '',
                '  // White outer glow',
                '  float outerGlow = pow(fresnel, 1.0) * uActiveGlow;',
                '  vec3 glowColor = mix(uColor, vec3(1.0, 0.95, 0.85), outerGlow * 0.5);',
                '',
                '  energy *= electricPool;',
                '  energy += outerGlow * 0.4;',
                '  vec3 col = glowColor * (1.0 + energy * 2.0 + outerGlow * 2.0);',
                '',
                '  gl_FragColor = vec4(col, energy * uOpacity + outerGlow * 0.3);',
                '}'
            ].join('\n');

            // Layer Config
            var allLayers = [
                { id:'L1',  r:2.90, c:[1.00,1.00,1.00], zone:'silicon',  fp:3.5 },
                { id:'L2',  r:2.72, c:[1.00,1.00,1.00], zone:'silicon',  fp:3.2 },
                { id:'L3',  r:2.55, c:[1.00,1.00,1.00], zone:'silicon',  fp:3.0 },
                { id:'L4',  r:2.38, c:[1.00,1.00,1.00], zone:'silicon',  fp:2.8 },
                { id:'L5',  r:2.22, c:[1.00,1.00,1.00], zone:'silicon',  fp:2.6 },
                { id:'L6',  r:2.06, c:[1.00,1.00,1.00], zone:'silicon',  fp:2.5 },
                { id:'L7',  r:1.90, c:[1.00,1.00,1.00], zone:'silicon',  fp:2.4 },
                { id:'L8',  r:1.72, c:[0.20,0.55,0.60], zone:'gateway',  fp:2.0 },
                { id:'L9',  r:1.52, c:[0.20,0.87,0.87], zone:'biology',  fp:2.8 },
                { id:'L10', r:1.38, c:[0.50,0.93,0.93], zone:'biology',  fp:2.6 },
                { id:'L11', r:1.24, c:[1.00,1.00,1.00], zone:'biology',  fp:2.4 },
                { id:'L12', r:1.10, c:[1.00,1.00,1.00], zone:'biology',  fp:2.3 },
                { id:'L13', r:0.96, c:[1.00,1.00,1.00], zone:'biology',  fp:2.2 },
                { id:'L14', r:0.82, c:[0.80,0.55,0.75], zone:'biology',  fp:2.0 },
            ];

            var mobileIdx = [0,2,4,6,7,9,11,13];
            var activeLayers = (isMobile || isTablet) ? mobileIdx.map(function(i){return allLayers[i];}) : allLayers;

            // Shells
            var shellGeo = new THREE.SphereGeometry(1, isMobile ? 32 : 64, isMobile ? 24 : 48);
            var shellMeshes = [], shellUniforms = [];

            activeLayers.forEach(function(layer, idx) {
                var isGW = layer.zone === 'gateway';
                // Bubble gradient: L14=0.80, L13=0.70, ..., L9=0.30, L8 and below=0
                var layerNum = parseInt(layer.id.replace('L',''));
                var bubbleMix = layerNum >= 9 ? Math.max(0, 0.80 - (14 - layerNum) * 0.10) : 0;
                var hasBlend = bubbleMix > 0;
                var useSpecialShader = isGW || hasBlend;
                var u = {
                    uColor: { value: new THREE.Vector3(layer.c[0], layer.c[1], layer.c[2]) },
                    uOpacity: { value: useSpecialShader ? 0.7 : 0.45 },
                    uFresnelPower: { value: layer.fp },
                    uGlowIntensity: { value: useSpecialShader ? 2.5 : 1.2 },
                    uTime: { value: 0 },
                    uActiveGlow: { value: 0.0 }
                };
                if (hasBlend) u.uBubbleMix = { value: bubbleMix };
                var fragShader = hasBlend ? blendFrag : (isGW ? gatewayFrag : fresnelFrag);
                var mat = new THREE.ShaderMaterial({
                    uniforms: u,
                    vertexShader: fresnelVert,
                    fragmentShader: fragShader,
                    transparent: true,
                    side: THREE.FrontSide,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                });
                var mesh = new THREE.Mesh(shellGeo, mat);
                mesh.scale.setScalar(layer.r);
                mesh.userData = layer;
                parallaxGroup.add(mesh);
                shellMeshes.push(mesh);
                shellUniforms.push(u);
            });

            // Laser-etched frosted glass labels for each layer disc
            var labelMeshes = [];
            var labelNames = {
                L1:'Physical Carrier', L2:'Signal Processing', L3:'Protocol',
                L4:'Transport', L5:'Session', L6:'Presentation', L7:'Application Interface',
                L8:'Neural Gateway',
                L9:'Signal Processing', L10:'Neural Protocol', L11:'Cognitive Transport',
                L12:'Cognitive Session', L13:'Semantic Layer', L14:'Identity Layer'
            };
            var labelDomains = {
                silicon:'OSI', gateway:'Bridge', biology:'Neural'
            };
            activeLayers.forEach(function(layer, i) {
                var canvas = document.createElement('canvas');
                canvas.width = 1024; canvas.height = 1024;
                var ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, 1024, 1024);

                var name = labelNames[layer.id] || layer.id;
                var domain = labelDomains[layer.zone] || '';
                var line1 = layer.id + '  ·  ' + name;
                var line2 = domain;

                // Frosted etch: multiple blur passes for soft glow
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Pass 1: wide glow (frosted halo)
                ctx.shadowColor = 'rgba(255,255,255,0.3)';
                ctx.shadowBlur = 30;
                ctx.fillStyle = 'rgba(255,255,255,0.12)';
                ctx.font = '600 64px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
                ctx.fillText(line1, 512, 460);
                ctx.font = '400 40px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
                ctx.fillText(line2, 512, 540);

                // Pass 2: medium glow
                ctx.shadowBlur = 12;
                ctx.fillStyle = 'rgba(255,255,255,0.2)';
                ctx.font = '600 64px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
                ctx.fillText(line1, 512, 460);
                ctx.font = '400 40px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
                ctx.fillText(line2, 512, 540);

                // Pass 3: sharp etched text
                ctx.shadowColor = 'rgba(255,255,255,0.5)';
                ctx.shadowBlur = 3;
                ctx.fillStyle = 'rgba(255,255,255,0.45)';
                ctx.font = '600 64px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
                ctx.fillText(line1, 512, 460);
                ctx.font = '400 40px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
                ctx.fillText(line2, 512, 540);

                // Thin horizontal etch line
                ctx.shadowBlur = 8;
                ctx.shadowColor = 'rgba(255,255,255,0.2)';
                ctx.strokeStyle = 'rgba(255,255,255,0.15)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(340, 500);
                ctx.lineTo(684, 500);
                ctx.stroke();

                var texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;

                var labelGeo = new THREE.PlaneGeometry(2, 2);
                var labelMat = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    opacity: 0,
                    depthWrite: false,
                    side: THREE.DoubleSide,
                });
                var lm = new THREE.Mesh(labelGeo, labelMat);
                lm.renderOrder = 10;
                parallaxGroup.add(lm);
                labelMeshes.push(lm);
            });

            // ONI closing text — HTML vector overlay for "NI"; the merged disc IS the "O"
            var niOverlay = document.getElementById('oni-ni-overlay');
            var niOpacity = 0; // lerped 0→1
            var niProjection = new THREE.Vector3(); // reusable for projection

            // Spring art overlay
            var springArtOverlay = document.getElementById('spring-art-overlay');
            var springEggEl = document.getElementById('spring-egg');
            var seizureWarningEl = document.getElementById('seizure-warning');
            var heroOsiTaglineTop = document.getElementById('hero-osi-tagline-top');
            var heroNeuroLine = document.getElementById('hero-neuro-line');
            var heroOsiLine = document.getElementById('hero-osi-line');
            // Text intro: driven by animation loop, not setTimeout
            var heroAuthorLine = document.getElementById('hero-author-line');
            var heroQuoteOverlay = document.getElementById('hero-quote-overlay');
            window._introSeqStarted = false;
            window._introSeqTime = 0;
            // Position text at L8 initially (will be updated in animate)
            heroOsiTaglineTop.style.top = '50%';
            heroOsiTaglineTop.style.opacity = '0';
            var seizureWarningDismissed = false;
            springEggEl.addEventListener('click', function() {
                if (springEggActive) {
                    window.location.href = 'mai' + 'lto:' + _demail();
                }
            });

            // Wireframe overlays removed
            var wireMeshes = [];

            // Brain removed — stub variables to prevent reference errors
            var noop = function(){};
            var stubPos = { x:0, y:0, z:0, copy:noop, set:noop };
            var stubScale = { x:1, y:1, z:1, set:noop, setScalar:noop };
            var stubRot = { x:0, y:0, z:0, copy:noop, set:noop };
            var coreMesh = { visible:false, position:stubPos, scale:stubScale, rotation:stubRot, material:{ opacity:0 } };
            var glowMesh = { visible:false, position:{ x:0,y:0,z:0 }, scale:{ x:1,y:1,z:1, set:noop, setScalar:noop } };
            var glowMat = { color:{ setRGB:noop }, opacity:0 };
            var nodeCloud = { visible:false, position:{ x:0,y:0,z:0 }, scale:{ set:noop } };
            var synapseLines = null;
            var ghostL8Mesh = { visible:false, position:{ copy:noop }, scale:{ set:noop }, rotation:{ copy:noop } };
            var ghostL8Uniforms = { uColor:{ value:{ x:0,y:0,z:0, copy:noop, set:noop } }, uOpacity:{ value:0 }, uTime:{ value:0 }, uGlowIntensity:{ value:0 } };
            var coreU = { uTime:{ value:0 } };
            var nodeU = { uTime:{ value:0 } };

            // Ambient Dust
            var dustCount = isMobile ? 80 : 200;
            var dPos = new Float32Array(dustCount*3);
            for (var i=0; i<dustCount; i++) {
                dPos[i*3]   = (Math.random()-0.5)*10;
                dPos[i*3+1] = (Math.random()-0.5)*8;
                dPos[i*3+2] = (Math.random()-0.5)*6;
            }
            var dustGeo = new THREE.BufferGeometry();
            dustGeo.setAttribute('position', new THREE.BufferAttribute(dPos,3));
            var dustCloud = new THREE.Points(dustGeo, new THREE.PointsMaterial({
                color: 0x60a5fa, size: 0.015, transparent: true, opacity: 0.3,
                depthWrite: false, blending: THREE.AdditiveBlending, sizeAttenuation: true,
            }));
            scene.add(dustCloud);

            // Mouse parallax + gyroscope for mobile/tablet
            var mouseX = 0, mouseY = 0;
            var prevMouseX = 0, prevMouseY = 0, mouseDist = 0;
            if (!isMobile && !isTablet) {
                document.addEventListener('mousemove', function(e) {
                    var newMX = (e.clientX / window.innerWidth - 0.5) * 2;
                    var newMY = (e.clientY / window.innerHeight - 0.5) * 2;
                    var dx = newMX - prevMouseX, dy = newMY - prevMouseY;
                    mouseDist += Math.sqrt(dx * dx + dy * dy);
                    prevMouseX = newMX; prevMouseY = newMY;
                    mouseX = newMX; mouseY = newMY;
                });
            }

            // Gyroscope: map device tilt to mouseX/mouseY on phones & tablets
            var gyroAvailable = false;
            var gyroBeta = 0, gyroGamma = 0; // beta = front/back tilt, gamma = left/right
            function handleOrientation(e) {
                if (e.beta === null || e.gamma === null) return;
                gyroAvailable = true;
                // beta: -180→180 (front/back). Neutral ~45° when held in hand. Map 0→90 to -1→1
                gyroBeta = Math.max(-1, Math.min(1, (e.beta - 45) / 45));
                // gamma: -90→90 (left/right). Map -45→45 to -1→1
                gyroGamma = Math.max(-1, Math.min(1, e.gamma / 45));
            }
            if (isMobile || isTablet) {
                // iOS 13+ requires permission request
                if (typeof DeviceOrientationEvent !== 'undefined' &&
                    typeof DeviceOrientationEvent.requestPermission === 'function') {
                    // Request on first user interaction
                    var gyroRequested = false;
                    document.addEventListener('touchstart', function() {
                        if (gyroRequested) return;
                        gyroRequested = true;
                        DeviceOrientationEvent.requestPermission().then(function(state) {
                            if (state === 'granted') {
                                window.addEventListener('deviceorientation', handleOrientation);
                            }
                        }).catch(function() {});
                    }, { once: false });
                } else {
                    // Android and non-iOS: just listen
                    window.addEventListener('deviceorientation', handleOrientation);
                }
            }

            // Visibility observer
            var clock = new THREE.Clock();
            var isVisible = true;

            var visObs = new IntersectionObserver(function(entries) {
                isVisible = entries[0].isIntersecting;
            }, { threshold: 0 });
            visObs.observe(threeContainer);

            // Resize
            function onResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            window.addEventListener('resize', onResize);

            // =============================================
            // CLICK-TO-EXPLORE: Raycaster + interaction
            // =============================================
            var raycaster = new THREE.Raycaster();
            var rayMouse = new THREE.Vector2();
            var hoveredShellIndex = -1;
            var prevHoveredShellIndex = -1;
            var hoverRippleCenter = -1;
            var hoverRippleStart = -1;
            var canvasInteractive = false;
            var clickHint = document.getElementById('click-hint');
            var hasInteracted = false; // hide hint permanently after first hover/click
            var hoverTooltip = document.getElementById('hover-tooltip');
            var hoverTooltipZone = hoverTooltip.querySelector('.hover-tooltip-zone');
            var hoverTooltipId = hoverTooltip.querySelector('.hover-tooltip-id');
            var hoverTooltipName = hoverTooltip.querySelector('.hover-tooltip-name');
            var hoverTooltipAction = hoverTooltip.querySelector('.hover-tooltip-action');
            var lastMouseClientX = 0, lastMouseClientY = 0;

            // Track mouse for raycasting and tooltip positioning
            document.addEventListener('mousemove', function(e) {
                rayMouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                rayMouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                lastMouseClientX = e.clientX;
                lastMouseClientY = e.clientY;
            });

            // Click handler: toggle active layer (full pull-out)
            function handleLayerClick(clientX, clientY) {
                // Easter egg: tap L14 while spring is compressed (L14 is red) → trigger cone bloom
                if (springCompress > 0.6 && !easterEggActive) {
                    var eeRay = new THREE.Vector2(
                        (clientX / window.innerWidth) * 2 - 1,
                        -(clientY / window.innerHeight) * 2 + 1
                    );
                    var eeRC = new THREE.Raycaster();
                    eeRC.setFromCamera(eeRay, camera);
                    var l14Idx = activeLayers.length - 1;
                    var eeHits = eeRC.intersectObject(shellMeshes[l14Idx]);
                    if (eeHits.length > 0) {
                        easterEggActive = true;
                        return; // consume the click
                    }
                }
                if (morphProgress.value < 0.15 || introProgress.value < 0.95 || activeGroupMode === 'closing') return;
                rayMouse.x = (clientX / window.innerWidth) * 2 - 1;
                rayMouse.y = -(clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(rayMouse, camera);
                var intersects = raycaster.intersectObjects(shellMeshes);
                if (intersects.length > 0) {
                    var clickedIndex = shellMeshes.indexOf(intersects[0].object);
                    if (clickedIndex === activeLayerIndex) {
                        // Deactivate
                        activeLayerIndex = -1;
                        activeZone = 'all';
                        updateHud(null);
                    } else {
                        // Activate this layer (full pull-out)
                        activeLayerIndex = clickedIndex;
                        var eLayer = activeLayers[clickedIndex];
                        activeZone = eLayer.zone;
                        updateHud(eLayer.id, eLayer.zone);
                        hasInteracted = true;
                    }
                } else {
                    // Clicked empty space — deactivate
                    activeLayerIndex = -1;
                    activeZone = 'all';
                    updateHud(null);
                }
            }

            // Listen on document — canvas is behind content z-index so direct canvas clicks won't reach
            document.addEventListener('click', function(e) {
                if (!canvasInteractive) return;
                handleLayerClick(e.clientX, e.clientY);
            });

            // Mobile touch support (tap detection)
            var touchStartPos = null;
            document.addEventListener('touchstart', function(e) {
                touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }, { passive: true });
            document.addEventListener('touchend', function(e) {
                if (!touchStartPos || !canvasInteractive) return;
                var tx = e.changedTouches[0].clientX;
                var ty = e.changedTouches[0].clientY;
                var dist = Math.hypot(tx - touchStartPos.x, ty - touchStartPos.y);
                if (dist < 15) {
                    handleLayerClick(tx, ty);
                }
                touchStartPos = null;
            }, { passive: true });

            // Gateway index (top-level for easter egg + other references)
            var gwIdxGlobal = -1;
            for (var gi = 0; gi < activeLayers.length; gi++) {
                if (activeLayers[gi].zone === 'gateway') { gwIdxGlobal = gi; break; }
            }

            // =============================================
            // EASTER EGG: Spring compress L14→L8, then cone bloom
            // =============================================
            var easterEggActive = false;  // triggered by tapping red L14
            var easterEggPhase = 0;       // 0→1: exponential expansion progress (lerped)

            // Toggle interactive class based on scroll position
            ScrollTrigger.create({
                trigger: '#scene-framework',
                start: 'top 80%',
                end: 'bottom 20%',
                onEnter: function() { threeContainer.classList.add('interactive'); canvasInteractive = true; },
                onLeave: function() { threeContainer.classList.remove('interactive'); canvasInteractive = false; activeLayerIndex = -1; activeZone = 'all'; updateHud(null); clickHint.classList.remove('visible'); },
                onEnterBack: function() { threeContainer.classList.add('interactive'); canvasInteractive = true; },
                onLeaveBack: function() { threeContainer.classList.remove('interactive'); canvasInteractive = false; activeLayerIndex = -1; activeZone = 'all'; updateHud(null); clickHint.classList.remove('visible'); }
            });

            // =============================================
            // INTRO: Stack → Sphere (on page load)
            // =============================================
            // Scroll-driven brightness: each wheel tick progressively restores layers
            // scrollBrightness 0→14: how many layers have been fully restored (L14 first)
            // Start at 14 so layers are fully bright during intro expand
            var scrollBrightness = 14;
            window.addEventListener('wheel', function() {
                if (scrollBrightness < 14) {
                    scrollBrightness = Math.min(14, scrollBrightness + 1.5); // ~1.5 layers per tick
                }
            }, { passive: true });
            window.addEventListener('touchmove', function() {
                if (scrollBrightness < 14) {
                    scrollBrightness = Math.min(14, scrollBrightness + 1.5);
                }
            }, { passive: true });

            // TODO: Arrow key easter egg (future implementation)
            // When user presses ArrowDown or ArrowUp at the top of the page:
            //   - Each press shifts L14 through the visible spectrum (same as spring pull)
            //   - After a few presses, show a message: "Come back for another easter egg and more surprises!"
            //   - Could reuse the #easter-egg-overlay with custom text
            //   - ArrowDown = advance spectrum forward, ArrowUp = advance spectrum backward
            //   - Track arrow presses separately from scroll spring (e.g. arrowSpectrumPos 0→1)

            // Spring coil: scroll-up at top of page compresses L14→L8 downward
            // Like a tension spring — L14 moves most, L9 barely, L8 anchored
            var springCompress = 0; // 0 = normal, 1 = fully compressed
            var springTarget = 0;
            var rippleWavePos = 0; // cumulative wave position — advances on each scroll impulse
            var rippleIntensity = 0; // current ripple brightness — spikes on scroll, decays per frame
            // Spring egg: appears from L14 center at extreme compression
            var springEggActive = false;
            var springEggWasActive = false; // tracks previous frame
            var rainbowRippleTime = -1; // timestamp when ripple starts, -1 = inactive
            var springPeakCompress = 0; // tracks highest springCompress reached
            var colorResetPending = false; // true after egg, waiting for L8 to shrink
            // Obfuscated email — assembled at runtime, never in plaintext
            var _eparts = [107,101,118,105,110,113,105,99,111,100,101,64,103,109,97,105,108,46,99,111,109];
            function _demail() { return _eparts.map(function(c){return String.fromCharCode(c)}).join(''); }
            window.addEventListener('wheel', function(e) {
                if (window.scrollY < 10 && e.deltaY < 0 && introProgress.value > 0.9) {
                    // Progressive resistance: hard to start, eases as you push further
                    var t01 = springTarget / 2.0;
                    var scrollRate = 0.002 + t01 * t01 * 0.006;
                    springTarget = Math.min(2.0, springTarget + Math.abs(e.deltaY) * scrollRate);
                    // Feed ripple wave on every scroll event during spring
                    if (springTarget > 0.3) {
                        rippleWavePos += Math.abs(e.deltaY) * 0.008;
                        rippleIntensity = Math.min(1, rippleIntensity + Math.abs(e.deltaY) * 0.015);
                    }
                } else if (e.deltaY > 0) {
                    // Scrolling down — release spring
                    springTarget = Math.max(0, springTarget - Math.abs(e.deltaY) * 0.006);
                }
            }, { passive: true });
            // Touch support for spring
            var touchStartY = 0;
            window.addEventListener('touchstart', function(e) {
                touchStartY = e.touches[0].clientY;
            }, { passive: true });
            window.addEventListener('touchmove', function(e) {
                var dy = e.touches[0].clientY - touchStartY;
                touchStartY = e.touches[0].clientY;
                if (window.scrollY < 10 && dy > 0 && introProgress.value > 0.9) {
                    var t01t = springTarget / 2.0;
                    var touchRate = 0.002 + t01t * t01t * 0.006;
                    springTarget = Math.min(2.0, springTarget + dy * touchRate);
                    if (springTarget > 0.3) {
                        rippleWavePos += dy * 0.008;
                        rippleIntensity = Math.min(1, rippleIntensity + dy * 0.015);
                    }
                } else if (dy < 0) {
                    springTarget = Math.max(0, springTarget + dy * 0.006);
                }
            }, { passive: true });

            // Track peak spring compression for progressive layer reveal (L7→L1)
            // Once revealed, layers stay visible even when spring releases
            var springRevealLevel = 0;

            // Intro: biology layers emerge from L8 with slinky bounce
            var introProgress = { value: 1 };

            // =============================================
            // SPHERE → STACK MORPH (GSAP ScrollTrigger)
            // =============================================
            var morphProgress = { value: 0 };
            var originalRadii = activeLayers.map(function(l) { return l.r; });

            // Morph triggered when entering framework section
            gsap.to(morphProgress, {
                value: 1,
                scrollTrigger: {
                    trigger: '#scene-framework',
                    start: 'top 80%',
                    end: 'top 20%',
                    scrub: 1,
                },
                ease: 'none'
            });

            // Problem collapse: biology layers merge downward L14→L13→...→L8
            var problemCollapse = { value: 0 };
            gsap.to(problemCollapse, {
                value: 1,
                scrollTrigger: {
                    trigger: '#scene-problem',
                    start: 'top 80%',
                    end: 'top 20%',
                    scrub: 1
                },
                ease: 'none'
            });

            // centerTilt disabled (end scene removed)
            var centerTilt = { value: 0 };

            // Foundations transition: layers face camera, then canvas fades
            var closingShrink = { value: 0 }; // 0 = stack discs, 1 = compressed + shrunk
            gsap.to(closingShrink, {
                value: 1,
                scrollTrigger: {
                    trigger: '#scene-proof',
                    start: 'top 95%',
                    end: 'top 40%',
                    scrub: 1
                },
                ease: 'none'
            });
            gsap.to(threeContainer, {
                scrollTrigger: {
                    trigger: '#scene-proof',
                    start: 'top 55%',
                    end: 'top 20%',
                    scrub: 1
                },
                opacity: 0
            });

            // Restore opacity on scroll back
            ScrollTrigger.create({
                trigger: '#scene-hero',
                start: 'top top',
                end: 'bottom top',
                onEnter: function() { threeContainer.style.opacity = '1'; },
                onEnterBack: function() { threeContainer.style.opacity = '1'; }
            });

            // =============================================
            // TUNNEL / SLINKY SCROLL TRIGGER
            // =============================================
            var tunnelProgress = { value: 0 };
            gsap.to(tunnelProgress, {
                value: 1,
                scrollTrigger: {
                    trigger: '#scene-tunnel',
                    start: 'top 80%',
                    end: 'bottom 20%',
                    scrub: 1
                },
                ease: 'none'
            });
            // Fade canvas back in for tunnel
            gsap.to(threeContainer, {
                scrollTrigger: {
                    trigger: '#scene-tunnel',
                    start: 'top 90%',
                    end: 'top 50%',
                    scrub: 1
                },
                opacity: 1
            });

            // =============================================
            // PER-LAYER SCROLL TRACKING + HUD
            // =============================================
            var activeLayerIndex = -1;
            var activeZone = 'all';
            var activeGroupMode = null; // 'closing' when layers merge into ONI
            // HUD elements
            var layerHud = document.getElementById('layer-hud');
            var layerHudBadge = document.getElementById('layer-hud-badge');
            var layerHudName = document.getElementById('layer-hud-name');
            var layerHudZone = document.getElementById('layer-hud-zone');

            // Layer data lookup
            var layerData = {
                OSI: { name:'Classical OSI Layers', tag:'Layers 1\u20137 \u00B7 The Foundation', tagClass:'osi',
                    desc:'These 7 layers mirror the OSI model that powers every network on Earth \u2014 from physical hardware to application software. ONI maps them directly to the silicon side of brain-computer interfaces.',
                    context:'Physical \u00B7 Data Link \u00B7 Network \u00B7 Transport \u00B7 Session \u00B7 Presentation \u00B7 Application' },
                L1: { name:'Physical Carrier', tag:'OSI: Physical Layer', tagClass:'osi',
                    desc:'The hardware that touches your body \u2014 electrodes, wires, wireless signals carrying neural data from brain to device.',
                    context:'Think: the cables and radio waves that carry internet traffic' },
                L2: { name:'Signal Processing', tag:'OSI: Data Link', tagClass:'osi',
                    desc:'Cleaning raw brain signals \u2014 filtering noise, amplifying patterns, organizing data into usable frames.',
                    context:'Think: Ethernet frames that package raw data for delivery' },
                L3: { name:'Protocol', tag:'OSI: Network', tagClass:'osi',
                    desc:'Routing rules for neural data \u2014 which signals go where, how packets are addressed across the interface.',
                    context:'Think: IP addresses that route traffic across the internet' },
                L4: { name:'Transport', tag:'OSI: Transport', tagClass:'osi',
                    desc:'Ensuring neural data arrives complete and in order \u2014 reliable delivery between device and processing systems.',
                    context:'Think: TCP ensuring your web page loads without missing pieces' },
                L5: { name:'Session', tag:'OSI: Session', tagClass:'osi',
                    desc:'Managing the conversation between device and brain \u2014 connection lifecycle, state management, synchronization.',
                    context:'Think: staying logged in while you browse a website' },
                L6: { name:'Presentation', tag:'OSI: Presentation', tagClass:'osi',
                    desc:'Translating neural data into formats software understands \u2014 encoding, compression, encryption.',
                    context:'Think: SSL encryption and data formatting for secure communication' },
                L7: { name:'Application Interface', tag:'OSI: Application', tagClass:'osi',
                    desc:'The software layer \u2014 BCI apps, prosthetic control panels, neurofeedback dashboards.',
                    context:'Think: the apps and browsers you use every day' },
                L8: { name:'Neural Gateway', tag:'The Neural Firewall', tagClass:'gateway-tag',
                    desc:'The boundary between machine and mind. Every signal crossing this layer is measured against the Coherence Metric \u2014 a mathematical signature of signal integrity. No equivalent exists in traditional networking.',
                    context:'If coherence drops below threshold, the signal is rejected before it reaches biology.',
                    formula:'C\u209B = e\u207B\u207D\u03C3\u00B2\u03C6 + \u03C3\u00B2\u03C4 + \u03C3\u00B2\u03B3\u207E' },
                L9: { name:'Signal Processing', tag:'Beyond OSI \u2014 Biological Domain', tagClass:'novel',
                    desc:'Your brain\u2019s own noise filter \u2014 how neurons clean, amplify, and gate the signals they receive from the interface.',
                    context:'Biological filtering at the ion channel level' },
                L10: { name:'Neural Protocol', tag:'Beyond OSI \u2014 Biological Domain', tagClass:'novel',
                    desc:'How your brain encodes information \u2014 the electrochemical language neurons use to communicate with each other.',
                    context:'Neurotransmitter signaling and spike-timing patterns' },
                L11: { name:'Cognitive Transport', tag:'Beyond OSI \u2014 Biological Domain', tagClass:'novel',
                    desc:'How thoughts travel across brain regions \u2014 the neural highways connecting perception, memory, and action.',
                    context:'White matter tracts and cross-regional neural routing' },
                L12: { name:'Cognitive Session', tag:'Beyond OSI \u2014 Biological Domain', tagClass:'novel',
                    desc:'Your brain\u2019s working memory and attention \u2014 the context window that makes thoughts coherent and meaningful.',
                    context:'Prefrontal cortex state management and attentional gating' },
                L13: { name:'Semantic Layer', tag:'Beyond OSI \u2014 Biological Domain', tagClass:'novel',
                    desc:'Where signals become meaning \u2014 how your brain turns neural patterns into understanding, intention, and decisions.',
                    context:'Higher-order cognition, intent formation, and decision-making' },
                L14: { name:'Identity Layer', tag:'Beyond OSI \u2014 Biological Domain', tagClass:'novel',
                    desc:'Your sense of self \u2014 consciousness, personality, the subjective \u201Cyou\u201D that experiences everything. The deepest layer to protect.',
                    context:'Neural correlates of consciousness and personal identity' }
            };
            var zoneLabels = { silicon:'Silicon', gateway:'Gateway', biology:'Biology' };

            // Detail overlay elements
            var layerDetail = document.getElementById('layer-detail');
            var layerDetailTag = document.getElementById('layer-detail-tag');
            var layerDetailDesc = document.getElementById('layer-detail-desc');
            var layerDetailContext = document.getElementById('layer-detail-context');
            var layerDetailFormula = document.getElementById('layer-detail-formula');

            // Build a mapping from layer ID (L1-L14) to shell index
            var layerIdToShellIndex = {};
            activeLayers.forEach(function(layer, idx) {
                layerIdToShellIndex[layer.id] = idx;
            });

            function updateHud(lid, zone) {
                if (!layerHud) return;
                var data = lid ? layerData[lid] : null;
                if (data) {
                    // Bottom HUD
                    layerHudBadge.textContent = (lid === 'OSI') ? 'L1\u20137' : lid;
                    layerHudBadge.className = 'layer-hud-badge ' + zone;
                    layerHudName.textContent = data.name;
                    layerHudZone.textContent = zoneLabels[zone] || '';
                    layerHud.classList.add('visible');

                    // Center detail overlay
                    layerDetailTag.textContent = data.tag;
                    layerDetailTag.className = 'layer-detail-tag ' + data.tagClass;
                    layerDetailDesc.textContent = data.desc;
                    layerDetailContext.textContent = data.context;
                    if (data.formula) {
                        layerDetailFormula.textContent = data.formula;
                        layerDetailFormula.style.display = 'inline-block';
                    } else {
                        layerDetailFormula.style.display = 'none';
                    }
                    layerDetail.classList.add('visible');
                } else {
                    layerHud.classList.remove('visible');
                    layerDetail.classList.remove('visible');
                }
            }

            // Intro trigger resets state
            ScrollTrigger.create({
                trigger: '.framework-intro-trigger',
                start: 'top 70%',
                end: 'bottom 30%',
                onToggle: function(self) {
                    if (self.isActive) {
                        activeLayerIndex = -1; activeZone = 'all'; activeGroupMode = null; updateHud(null);
                    }
                }
            });

            // Closing trigger: disabled for now (ONI animation saved for later)
            // ScrollTrigger.create({
            //     trigger: '.framework-closing-trigger',
            //     start: 'top 70%',
            //     end: 'bottom 30%',
            //     onToggle: function(self) {
            //         if (self.isActive) {
            //             activeLayerIndex = -1; activeZone = 'all';
            //             activeGroupMode = 'closing';
            //             updateHud(null);
            //         } else {
            //             activeGroupMode = null;
            //             updateHud(null);
            //         }
            //     }
            // });

            // Per-shell animation state (lerped in animation loop)
            var shellScaleMultipliers = activeLayers.map(function() { return 1.0; });
            var shellZOffsets = activeLayers.map(function() { return 0; });
            var shellYOffsets = activeLayers.map(function() { return 0; });
            var shellXOffsets = activeLayers.map(function() { return 0; });
            var shellFaceCamera = activeLayers.map(function() { return 0; });

            // Closing animation phase: 0→1 (convergence), then NI slides
            var closingPhase = 0;
            var niSlidePhase = 0; // 0→1: "O" and "NI" slide to center

            // =============================================
            // ANIMATION LOOP
            // =============================================
            function animate() {
                requestAnimationFrame(animate);
                if (!isVisible) return;

                var dt = clock.getDelta();
                var t = clock.getElapsedTime();

                // Shader uniforms
                shellUniforms.forEach(function(u) { u.uTime.value = t; });
                coreU.uTime.value = t;
                nodeU.uTime.value = t;

                // Clamp scroll morph at L13–L14 contact point (mitosis threshold)
                // Derived from: gap = 0.4·mp − (r₁₃ + r₁₄)(1 − 0.92·mp) = 0
                // → mp* = (r₁₃ + r₁₄) / (0.4 + 0.92·(r₁₃ + r₁₄)) = 1.78/2.0376 ≈ 0.874
                // Beyond this, L14–L13 edges separate and the solid-frustum illusion breaks.
                var rawMorph = morphProgress.value;
                var morphCap = 0.874;
                var clampedMorph = Math.min(rawMorph, morphCap);

                // OSI blurb: visible when L7 starts appearing (0.05), fades out when L1 appears (0.65)
                if (osiBlurbEl) {
                    var blurbIn = Math.max(0, Math.min(1, (rawMorph - 0.03) / 0.08)); // fade in 0.03→0.11
                    var blurbOut = Math.max(0, Math.min(1, (rawMorph - 0.55) / 0.10)); // fade out 0.55→0.65
                    var blurbOpacity = blurbIn * (1 - blurbOut);
                    osiBlurbEl.style.opacity = blurbOpacity;
                    osiBlurbEl.style.transform = 'translateY(' + ((1 - blurbIn) * 30 - blurbOut * 30) + 'px)';
                }

                // Scroll-driven cascade compression: after L1 appears (rawMorph > 0.65),
                // L1→L7 compress upward into L8 like tension spring
                var cascadeCompress = Math.max(0, Math.min(1, (rawMorph - 0.65) / 0.22)); // 0→1 over 0.65→0.87

                // Effective morph: force full stack (morphCap) whenever intro is active or done
                // introVal goes 0→1 and stays at 1. Scroll morph also goes 0→morphCap.
                // Use max so whichever is higher wins — intro keeps stack visible even before scroll.
                var introVal = introProgress.value;
                var introActive = introVal < 0.99;
                // Gradual sphere→disc morph during intro (spheres at 0, flat discs at 1)
                var introMorph = introVal * morphCap;
                var effectiveMorph = Math.max(introMorph, clampedMorph);

                // Auto-rotation (slows during morph, near-zero when layer pulled out)
                var maxFace = 0;
                for (var fi = 0; fi < shellFaceCamera.length; fi++) {
                    if (shellFaceCamera[fi] > maxFace) maxFace = shellFaceCamera[fi];
                }
                var pullDampen = 1 - maxFace; // full stop rotation when layer is pulled out
                var rotSpeed = 0.002 * (1 - effectiveMorph * 0.6) * pullDampen;
                autoRotateGroup.rotation.y += rotSpeed;
                autoRotateGroup.rotation.x = Math.sin(t*0.15)*0.08 * (1 - effectiveMorph * 0.8) * pullDampen;

                // When layer is pulled out, lerp group rotations toward zero to kill drift
                if (maxFace > 0.3) {
                    var resetLerp = maxFace * 0.08;
                    autoRotateGroup.rotation.y *= (1 - resetLerp);
                    autoRotateGroup.rotation.x *= (1 - resetLerp);
                }

                // Mouse / gyroscope parallax (near-zero when layer pulled out)
                // Desktop: mouse position drives tilt
                // Mobile/tablet: device gyroscope drives tilt
                var pxInput = mouseX, pyInput = mouseY;
                if ((isMobile || isTablet) && gyroAvailable) {
                    pxInput = gyroGamma; // left/right tilt
                    pyInput = gyroBeta;  // front/back tilt
                }
                {
                    var parallaxStr = (1 - effectiveMorph * 0.7) * pullDampen;
                    // Spring compression: boost parallax for full mouse-driven tilt
                    if (springCompress > 0.05) {
                        var springParallax = Math.min(1, springCompress * 2);
                        parallaxStr = Math.max(parallaxStr, springParallax) * pullDampen;
                    }
                    // Tunnel: reduce parallax to subtle
                    if (tunnelProgress.value > 0.01) {
                        parallaxStr *= (1 - tunnelProgress.value * 0.85);
                    }
                    var tiltMultX = 0.20;
                    var tiltMultY = 0.08;
                    // During spring: stronger tilt range on both axes
                    if (springCompress > 0.05) {
                        var springTiltBoost = Math.min(1, springCompress * 2);
                        tiltMultX = 2.0 + springTiltBoost * 1.0;
                        tiltMultY = 0.25 + springTiltBoost * 0.2;
                    }
                    var lerpX = 0.06, lerpY = 0.04;
                    if (springCompress > 0.05) {
                        lerpX = 0.12;
                        lerpY = 0.10;
                    }
                    if (springCompress < 0.05) {
                        // Auto-breathe tilt + mouse-driven tilt
                        var autoTiltX = Math.sin(t * 0.25) * 0.04 + pyInput * tiltMultX * parallaxStr;
                        var autoTiltY = Math.sin(t * 0.15) * 0.01 + pxInput * tiltMultY * parallaxStr;
                        parallaxGroup.rotation.x += (autoTiltX - parallaxGroup.rotation.x) * 0.06;
                        parallaxGroup.rotation.y += (autoTiltY - parallaxGroup.rotation.y) * 0.04;
                    } else {
                        parallaxGroup.rotation.x *= 0.92;
                        parallaxGroup.rotation.y *= 0.92;
                    }
                    // Reset parallax rotation when pulled out
                    if (maxFace > 0.3) {
                        parallaxGroup.rotation.x *= (1 - maxFace * 0.1);
                        parallaxGroup.rotation.y *= (1 - maxFace * 0.1);
                    }
                }

                // Global darken for brain/glow (uses scrollBrightness)
                var globalBright = Math.min(1, scrollBrightness / 3); // full after ~2 ticks
                var darkenMult = 0.3 + globalBright * 0.7; // 0.3→1.0

                // Brain/core — visible once intro expand is mostly done
                var pulse = 1 + Math.sin(t*1.2)*0.025;
                var mp = effectiveMorph;

                // Position brain at L8 in the stack
                var gwIdx = -1;
                for (var gi = 0; gi < activeLayers.length; gi++) {
                    if (activeLayers[gi].zone === 'gateway') { gwIdx = gi; break; }
                }
                var l8StackY = 0;
                if (gwIdx >= 0) {
                    var stackSpacingCore = 0.4;
                    l8StackY = (gwIdx - (activeLayers.length - 1) / 2) * stackSpacingCore;
                }
                coreMesh.position.y = l8StackY * mp;
                glowMesh.position.y = l8StackY * mp;
                nodeCloud.position.y = l8StackY * mp;
                if (synapseLines) synapseLines.position.y = l8StackY * mp;

                // Brain fades IN as intro expand completes (reverse of old behavior)
                // introVal: 0 = collapsed circle, 1 = fully expanded stack
                // bangProgress: used for ripple cascade timing (0→1 as layers expand)
                var bangProgress = introVal;
                var coreFade = Math.max(0, Math.min(1, (introVal - 0.7) / 0.3)); // fades in last 30% of intro

                if (springCompress < 0.01 && easterEggPhase < 0.01) {
                    // No spring tension — hide brain entirely
                    coreMesh.visible = false;
                    glowMesh.visible = false;
                    nodeCloud.visible = false;
                    if (synapseLines) synapseLines.visible = false;
                    ghostL8Mesh.visible = false;
                } else if (easterEggPhase > 0.01) {
                    // Cone bloom: brain glows ONI Teal, pulses with the bloom
                    var bloomPulse = 1 + Math.sin(t * 3.0) * 0.05 * easterEggPhase;
                    coreMesh.scale.setScalar(pulse * Math.max(coreFade, 0.3) * bloomPulse);
                    coreMesh.visible = true;
                    coreMesh.material.opacity = Math.max(coreFade, 0.6) * darkenMult;
                    glowMesh.visible = true;
                    glowMesh.scale.setScalar(pulse * 0.9 * bloomPulse);
                    var tealBlend = easterEggPhase;
                    glowMat.color.setRGB(
                        0.925 + (0.133 - 0.925) * tealBlend,
                        0.282 + (0.776 - 0.282) * tealBlend,
                        0.600 + (0.553 - 0.600) * tealBlend
                    );
                    glowMat.opacity = (0.2 + easterEggPhase * 0.25) * darkenMult;
                    var nodeFade = Math.max(0, Math.min(1, (introVal - 0.6) / 0.4));
                    var nodeScale = pulse * Math.max(nodeFade, 0.5);
                    nodeCloud.visible = true;
                    nodeCloud.scale.set(nodeScale, nodeScale*0.85, nodeScale);
                    if (synapseLines) {
                        synapseLines.visible = true;
                        synapseLines.scale.set(nodeScale, nodeScale*0.85, nodeScale);
                        synapseLines.material.opacity = (0.15 + easterEggPhase * 0.1) * darkenMult;
                    }
                } else {
                    // Spring compression active: brain appears then morphs into L8 clone
                    var springFadeIn = Math.min(1, springCompress * 5); // quick fade in over first 20% compression
                    var morphPhase = Math.min(1, springCompress * 2.5);
                    var brainAlive = 1 - morphPhase;
                    var ghostIn = morphPhase;
                    var ghostOut = Math.max(0, Math.min(1, (springCompress - 0.4) / 0.3));
                    var ghostOpacity = ghostIn * (1 - ghostOut);

                    // Brain: fade in, then flatten and fade
                    var brainBaseScale = pulse * springFadeIn;
                    var brainScaleXZ = brainBaseScale * (1 + morphPhase * 0.6);
                    var brainScaleY = brainBaseScale * (1 - morphPhase * 0.92);
                    coreMesh.scale.set(brainScaleXZ, brainScaleY, brainScaleXZ);
                    coreMesh.visible = brainAlive > 0.02 && springFadeIn > 0.01;
                    coreMesh.material.opacity = 0.9 * springFadeIn * brainAlive * darkenMult;

                    // Ghost L8 clone: appears at brain position matching L8's look
                    ghostL8Mesh.visible = ghostOpacity > 0.01;
                    if (ghostL8Mesh.visible) {
                        // Start as L8's color, turn white as it fully flattens
                        var toWhite = morphPhase * morphPhase; // accelerate toward white
                        if (gwIdx >= 0) {
                            var l8Col = shellUniforms[gwIdx].uColor.value;
                            ghostL8Uniforms.uColor.value.set(
                                l8Col.x + (1.0 - l8Col.x) * toWhite,
                                l8Col.y + (1.0 - l8Col.y) * toWhite,
                                l8Col.z + (1.0 - l8Col.z) * toWhite
                            );
                        }
                        ghostL8Uniforms.uOpacity.value = 0.7 * ghostOpacity;
                        ghostL8Uniforms.uTime.value = t;
                        ghostL8Uniforms.uGlowIntensity.value = 2.5;
                        // Scale: start at brain size, grow to match L8 radius
                        var l8R = gwIdx >= 0 ? originalRadii[gwIdx] : 1.72;
                        var ghostScaleXZ = brainBaseScale + (l8R - brainBaseScale) * morphPhase;
                        var ghostScaleY = ghostScaleXZ * (1 - mp * 0.92); // flatten like L8 disc
                        ghostL8Mesh.scale.set(ghostScaleXZ, ghostScaleY, ghostScaleXZ);
                        ghostL8Mesh.position.copy(coreMesh.position);
                        ghostL8Mesh.rotation.copy(shellMeshes[gwIdx >= 0 ? gwIdx : 0].rotation);
                    }

                    // Nodes and synapses: appear with spring, fade with brain
                    var nodeAlive = springFadeIn * brainAlive;
                    var nodeScale = pulse * nodeAlive;
                    var nodeScaleY = nodeScale * (1 - morphPhase * 0.9);
                    nodeCloud.visible = nodeAlive > 0.01;
                    nodeCloud.scale.set(nodeScale, nodeScaleY * 0.85, nodeScale);
                    if (synapseLines) {
                        synapseLines.visible = nodeAlive > 0.01;
                        synapseLines.scale.set(nodeScale, nodeScaleY * 0.85, nodeScale);
                        synapseLines.material.opacity = 0.15 * nodeAlive * darkenMult;
                    }
                    glowMesh.visible = springFadeIn > 0.02 && brainAlive > 0.02;
                    var glowBaseScale = pulse * 0.8 * springFadeIn;
                    glowMesh.scale.set(
                        glowBaseScale * (1 + morphPhase * 0.5),
                        glowBaseScale * (1 - morphPhase * 0.9),
                        glowBaseScale * (1 + morphPhase * 0.5)
                    );
                    glowMat.color.setRGB(0.925, 0.282, 0.600);
                    glowMat.opacity = (0.12 + Math.sin(t*1.8)*0.05) * springFadeIn * brainAlive * darkenMult;
                }

                // Stack offset: shift left when in stack mode (interactive), back to center otherwise
                // During closing, the disc slides left to form "O" in "ONI"
                var stackXTarget;
                if (activeGroupMode === 'closing') {
                    stackXTarget = niSlidePhase * -0.8; // slide left as "NI" approaches (tighter spacing)
                } else {
                    // Shift left when morphed to stack (framework section) so info overlay has room on right
                    var wantStackLeft = (rawMorph > 0.15 && canvasInteractive);
                    stackXTarget = wantStackLeft ? -2.0 : 0;
                }
                // Tunnel: blend group position toward center
                if (tunnelProgress.value > 0.01) {
                    stackXTarget += (0 - stackXTarget) * tunnelProgress.value;
                }
                autoRotateGroup.position.x += (stackXTarget - autoRotateGroup.position.x) * 0.06;

                // Spring coil: lerp toward target with damped spring feel
                // Auto-release: spring slowly returns to 0 when not actively scrolling up
                if (springTarget > 0 && window.scrollY >= 10) springTarget = 0;
                // Slower decay when easter egg is active so user can hold the cone
                var springDecay = easterEggActive ? 0.997 : 0.992;
                springTarget *= springDecay;
                springCompress += (springTarget - springCompress) * 0.08; // damped lerp
                // Ripple wave: decay intensity when not scrolling
                rippleIntensity *= 0.93;
                if (springCompress < 0.2) { rippleWavePos = 0; rippleIntensity = 0; }
                var prevEggActive = springEggWasActive;
                springEggActive = springCompress > 1.95;
                // Track peak compression while egg is active
                if (springEggActive) springPeakCompress = springCompress;
                // Detect egg disappearing — trigger rainbow ripple + color reset pending
                if (prevEggActive && !springEggActive) {
                    rainbowRippleTime = t;
                    colorResetPending = true;
                }
                // Color reset: when L8 starts shrinking (spring dropping well below peak)
                if (colorResetPending && springCompress < springPeakCompress - 0.3) {
                    colorResetPending = false;
                    springPeakCompress = 0;
                    rainbowRippleTime = -1;
                    // Snap all layers back to defaults
                    for (var ri = 0; ri < shellUniforms.length; ri++) {
                        if (shellUniforms[ri]) {
                            shellUniforms[ri].uGlowIntensity.value = 1.2;
                            shellUniforms[ri].uActiveGlow.value = 0;
                        }
                    }
                }
                springEggWasActive = springEggActive;
                // Track peak spring for progressive L7→L1 reveal
                springRevealLevel = Math.max(springRevealLevel, springCompress);

                // Easter egg: activated by tapping red L14 when spring compressed
                // Once triggered, track how much MORE the user keeps pulling
                // The cone bloom grows as user continues scrolling up past the trigger point
                if (easterEggActive) {
                    // easterEggPhase driven by spring BEYOND the trigger threshold
                    // User must keep pulling to expand the cone
                    var coneTarget = Math.max(0, Math.min(1, (springCompress - 0.5) / 0.5));
                    easterEggPhase += (coneTarget - easterEggPhase) * 0.06;
                    // If spring fully releases, deactivate
                    if (springCompress < 0.1 && easterEggPhase < 0.02) {
                        easterEggActive = false;
                        easterEggPhase = 0;
                    }
                }

                // MORPH: Spheres → Flat Discs → Vertical Stack + Jenga Pull-Out
                var mp = effectiveMorph;

                // Closing phase lerp: ramp up when closing, reset when not
                var closingTarget = (activeGroupMode === 'closing' && mp > 0.5) ? 1.0 : 0.0;
                closingPhase += (closingTarget - closingPhase) * 0.04;
                // NI slide: starts after convergence is mostly done
                var niSlideTarget = (closingPhase > 0.7) ? 1.0 : 0.0;
                niSlidePhase += (niSlideTarget - niSlidePhase) * 0.04;

                // Precompute gateway index for collapse and stack spacing
                var gwIdx = -1;
                for (var gi = 0; gi < activeLayers.length; gi++) {
                    if (activeLayers[gi].zone === 'gateway') { gwIdx = gi; break; }
                }

                // Deactivate active layer when scrolling past framework section
                if ((closingShrink.value > 0.05 || tunnelProgress.value > 0.05) && activeLayerIndex >= 0) {
                    activeLayerIndex = -1;
                    activeZone = 'all';
                    updateHud(null);
                }

                // Determine per-shell targets based on active layer
                shellMeshes.forEach(function(mesh, i) {
                    var origR = originalRadii[i];
                    var layer = activeLayers[i];
                    var isGW = layer.zone === 'gateway';
                    var breathing = 1 + Math.sin(t*0.6+i*0.5)*0.006;

                    // Progressive reveal: L1-L7 hidden on load
                    // Appear via scroll-down (rawMorph) OR spring tension (springCompress)
                    // L7 first, then L6, L5... L1 last
                    var layerRevealed = true;
                    if (gwIdx >= 0 && i < gwIdx) {
                        var stepsBelow = gwIdx - 1 - i; // 0=L7, 6=L1
                        // Scroll-down reveal: spread across rawMorph 0.05→0.75
                        var scrollThreshold = 0.05 + stepsBelow * 0.10;
                        // Spring tension reveal: same stagger on springCompress
                        var springThreshold = 0.08 + stepsBelow * 0.12;
                        layerRevealed = rawMorph >= scrollThreshold || springCompress >= springThreshold;
                    }
                    mesh.visible = layerRevealed;
                    if (!layerRevealed) return; // skip all processing for hidden layers

                    // Compute targets for this shell
                    var scaleTarget = 1.0;
                    var targetOpacity;
                    var targetZ = 0;
                    var targetFace = 0;

                    var isSilicon = layer.zone === 'silicon';

                    if (activeGroupMode === 'closing' && mp > 0.5) {
                        // Closing: ALL layers simultaneously converge into one white "O"
                        // closingPhase ramps 0→1 via lerp (driven by animation loop)
                        var cp = closingPhase;

                        // All layers converge simultaneously — face camera, pull forward, uniform scale
                        scaleTarget = 1.0 + cp * 0.5; // grow to 1.5
                        targetZ = cp * 4.0;
                        targetFace = cp;

                        // Transition color toward white: increase activeGlow for all layers
                        var whiteTarget = cp * 0.8; // strong white blend
                        shellUniforms[i].uActiveGlow.value += (whiteTarget - shellUniforms[i].uActiveGlow.value) * 0.08;
                        shellUniforms[i].uGlowIntensity.value += (3.0 - shellUniforms[i].uGlowIntensity.value) * 0.06;

                        // L1 (outermost) fully visible, inner layers fade to form solid white disc
                        // As closingPhase increases, inner layers become more transparent
                        var innerFade = Math.max(0, 1.0 - cp * 0.85);
                        targetOpacity = (i === 0) ? 1.0 : innerFade * 0.4 + 0.1;
                    } else if (i === activeLayerIndex) {
                        // Active layer: expand first, then pull out
                        // Scale pull-out intensity by morph progress so it works during early morph
                        var pullStrength = Math.min(1, Math.max(0, (rawMorph - 0.15) / 0.35)); // 0→1 as rawMorph goes 0.15→0.5
                        var expandReady = shellScaleMultipliers[i] > (1.0 + 0.3 * pullStrength);
                        if (isGW) {
                            // L8 FLAMBOYANT: bigger scale, farther pull, pulsing scale
                            var gwPulse = Math.sin(t * 4.0) * 0.1 * pullStrength;
                            scaleTarget = 1.0 + (1.6 * pullStrength) + gwPulse;
                            targetOpacity = 1.0;
                            targetZ = expandReady ? (7.0 * pullStrength) : 0;
                        } else {
                            // Enlarged disc positioned to the right
                            scaleTarget = 1.0 + (0.9 * pullStrength);
                            targetOpacity = 1.0;
                            targetZ = expandReady ? (4.5 * pullStrength) : 0;
                        }
                        targetFace = pullStrength; // gated by zProgress anyway
                    } else if (i === hoveredShellIndex && hoveredShellIndex !== activeLayerIndex && activeGroupMode === null) {
                        // Hovered (not clicked): subtle expand + brighter, stays in stack
                        scaleTarget = isGW ? 1.2 : 1.12;
                        targetOpacity = isGW ? 1.0 : 0.8;
                        // targetZ and targetFace stay at 0 — no pull-out
                    } else if (activeLayerIndex === -1 && activeGroupMode === null) {
                        // No specific layer active — all visible
                        var zoneMatch = (activeZone === 'all') || (activeZone === layer.zone);
                        scaleTarget = 1.0;
                        targetOpacity = zoneMatch ? (isGW ? 0.85 : 0.55) : (isGW ? 0.3 : 0.15);
                    } else {
                        // Different layer is active — dim, but L8 neighbors get sympathetic push
                        var isGWActive = activeLayers[activeLayerIndex] && activeLayers[activeLayerIndex].zone === 'gateway';
                        if (isGWActive && gwIdx >= 0 && Math.abs(i - gwIdx) <= 2) {
                            // L8 flamboyant: neighbors push away slightly
                            var neighDist = Math.abs(i - gwIdx);
                            var neighPush = (neighDist === 1 ? 0.6 : 0.25) * Math.min(1, Math.max(0, (rawMorph - 0.15) / 0.35));
                            var neighDir = (i < gwIdx) ? -1 : 1;
                            targetZ = neighPush * neighDir;
                            scaleTarget = 1.0 - neighDist * 0.03;
                            targetOpacity = 0.35 - neighDist * 0.08;
                        } else {
                            scaleTarget = 0.9;
                            targetOpacity = isGW ? 0.15 : 0.07;
                        }
                    }

                    // Shared constants for collapse + morph
                    var totalLayers = activeLayers.length;
                    var stackSpacing = 0.4;

                    // Intro: biology layers emerge from L8 with slinky bounce
                    var introYTarget = -999; // sentinel: no override
                    var introTilt = 0; // 1 = face camera (flat), 0 = stack orientation
                    if (introActive) {
                        // Silicon layers hidden during intro
                        if (i < gwIdx) {
                            mesh.visible = false;
                            shellUniforms[i].uOpacity.value = 0;
                            targetOpacity = 0;
                        } else {
                            // L8's final stack Y
                            var l8Y = (gwIdx - (totalLayers - 1) / 2) * stackSpacing;
                            if (gwIdx >= 0 && gwIdx > gwIdx) l8Y += 0.15; // won't trigger for L8 itself

                            // This layer's final stack Y
                            var ownY = (i - (totalLayers - 1) / 2) * stackSpacing;
                            if (gwIdx >= 0 && i > gwIdx) ownY += 0.15;

                            // Per-layer staggered emergence from L8
                            var stepsFromL8 = i - gwIdx; // L8=0, L9=1, ..., L14=6
                            var layerDelay = stepsFromL8 * 0.09;
                            var layerProg = Math.max(0, Math.min(1, (introVal - layerDelay) / 0.28));
                            // Smoothstep
                            layerProg = layerProg * layerProg * (3 - 2 * layerProg);

                            if (layerProg < 0.001) {
                                mesh.visible = false;
                                shellUniforms[i].uOpacity.value = 0;
                                targetOpacity = 0;
                            } else {
                                mesh.visible = true;
                                // Spring uncompress: all layers start at L8's Y, spread outward
                                var spreadEase = layerProg * layerProg * (3 - 2 * layerProg);
                                introYTarget = l8Y + (ownY - l8Y) * spreadEase;

                                // Scale: fade in
                                shellScaleMultipliers[i] = Math.max(shellScaleMultipliers[i], spreadEase);

                                // Opacity: fade in
                                targetOpacity *= Math.max(0.15, layerProg);
                            }
                        }

                        // Global tilt: start facing camera (sphere), un-tilt
                        introTilt = Math.max(0, 1 - introVal * 1.5);
                        introTilt = introTilt * introTilt;
                    }

                    // Lerp scale
                    var scaleLerp = (scaleTarget > shellScaleMultipliers[i]) ? 0.1 : 0.12;
                    shellScaleMultipliers[i] += (scaleTarget - shellScaleMultipliers[i]) * scaleLerp;

                    // Phase 1: Z pull-out
                    var zLerpIn = 0.12;
                    var zLerp = (targetZ > shellZOffsets[i]) ? zLerpIn : 0.14;
                    shellZOffsets[i] += (targetZ - shellZOffsets[i]) * zLerp;

                    // How far along is the Z pull-out? (0→1)
                    var zProgress = (targetZ > 0.1) ? Math.min(1, shellZOffsets[i] / targetZ) : (1 - Math.min(1, shellZOffsets[i] / 0.5));

                    // Phase 2: Y centering — gates on Z being >40% done
                    var yGate = Math.max(0, (zProgress - 0.4) / 0.6);

                    // Intro expand tilt: face camera when collapsed, un-tilt as layers expand
                    if (introTilt > 0) {
                        targetFace = Math.max(targetFace, introTilt);
                    }

                    // Foundations scroll: layers tilt to face camera as 2D circles
                    var foundationsFace = closingShrink.value;
                    if (foundationsFace > 0.01) {
                        targetFace = Math.max(targetFace, foundationsFace);
                    }

                    // Phase 3: Face-camera tilt — gates on Z being >50% done (or intro/foundations tilt)
                    var faceGate = (introTilt > 0 || foundationsFace > 0.01) ? 1.0 : Math.max(0, (zProgress - 0.5) / 0.5);
                    var gatedFace = targetFace * faceGate;
                    var faceLerpIn = 0.12;
                    var faceLerp = (gatedFace > shellFaceCamera[i]) ? faceLerpIn : 0.15;
                    shellFaceCamera[i] += (gatedFace - shellFaceCamera[i]) * faceLerp;

                    if (mp < 0.01) {
                        // Pure sphere mode
                        mesh.scale.setScalar(origR * breathing);
                        mesh.position.set(0, 0, 0);
                        mesh.rotation.set(0, 0, 0);
                    } else {
                        // Morphing: flatten Y, separate positions
                        var sm = shellScaleMultipliers[i];
                        var stackScaleXZ = origR * breathing * sm;

                        // Uniform pull-out size: 50% of screen height
                        var camDist = camera.position.z - shellZOffsets[i];
                        var visibleH = 2 * camDist * Math.tan(Math.PI * 20 / 180);
                        var pullOutSize = visibleH * 0.25; // radius = half of 50% screen
                        var faceAmt = shellFaceCamera[i];
                        var scaleXZ = stackScaleXZ + (pullOutSize - stackScaleXZ) * faceAmt;

                        // ScaleY: thin disc in stack → full circle when pulled out
                        var discScaleY = origR * breathing * (1 - mp * 0.92);
                        var circleScaleY = scaleXZ; // match XZ for perfect circle
                        var scaleY = discScaleY + (circleScaleY - discScaleY) * faceAmt;

                        // Stack position: evenly distribute layers vertically
                        var stackY = (i - (totalLayers - 1) / 2) * stackSpacing;

                        // L8 gets extra gap
                        if (gwIdx >= 0) {
                            if (i < gwIdx) stackY -= 0.15;
                            if (i > gwIdx) stackY += 0.15;
                        }

                        // Spring coil: compress L8-L14 downward toward L7 on scroll-up at top
                        // L7 is the anchor — doesn't move
                        // Spring ratio: layers further from L7 compress more (quadratic)
                        if (springCompress > 0.001 && gwIdx >= 0 && i >= gwIdx) {
                            var stepsAboveAnchor = i - (gwIdx - 1); // L8=1, L9=2, ... L14=7
                            var maxSteps = totalLayers - gwIdx; // 7
                            // Quadratic spring: top layers compress proportionally more
                            var springRatio = (stepsAboveAnchor / maxSteps);
                            springRatio = springRatio * springRatio; // quadratic — L14 moves most
                            // Pull layer Y toward L7's Y position (one below gateway)
                            var anchorY = ((gwIdx - 1) - (totalLayers - 1) / 2) * stackSpacing;
                            var pullAmount = (stackY - anchorY) * springRatio * springCompress;
                            stackY -= pullAmount;
                        }

                        // Tunnel perspective: all layers grow during compression,
                        // L14 grows most (closest), L1 grows least (farthest)
                        if (springCompress > 0.01) {
                            var depthRatio = i / (totalLayers - 1); // L1=0, L14=1
                            var baseGrow = 0.25; // minimum growth for L1
                            var extraGrow = 0.45; // additional growth for L14
                            var tunnelScale = 1 + springCompress * (baseGrow + depthRatio * extraGrow);
                            scaleTarget *= tunnelScale;
                        }

                        // Silicon layers emerge from L14's position and cascade down to their stack positions
                        // L7 appears first (nearest to L14), L1 last (farthest)
                        if (gwIdx >= 0 && i < gwIdx) {
                            var stepsBelow = gwIdx - 1 - i; // 0=L7, 6=L1
                            var scrollStart = 0.05 + stepsBelow * 0.10;
                            var scrollEnd = scrollStart + 0.25; // longer travel duration
                            var descendProgress = Math.max(0, Math.min(1, (rawMorph - scrollStart) / (scrollEnd - scrollStart)));
                            // Cubic ease-out for smooth landing
                            descendProgress = descendProgress * descendProgress * (3 - 2 * descendProgress);
                            // L14's stack Y position (where bio layers collapsed to)
                            var l14StackY = ((totalLayers - 1) - (totalLayers - 1) / 2) * stackSpacing + 0.15;
                            // Lerp from L14's Y down to this layer's own stackY
                            stackY = l14StackY + (stackY - l14StackY) * descendProgress;
                        }

                        // Cascade collapse removed — L1-L7 now expand and stay visible

                        // Scroll compression: as user scrolls down toward Foundations,
                        // L14→L1 compress downward — same quadratic ratio as spring coil
                        // L1 is anchor (bottom), L14 moves most (top)
                        var scrollCompressAmt = closingShrink.value;
                        if (scrollCompressAmt > 0.001 && i > 0) {
                            var stepsFromBottom = i; // L1=0 (anchor), L14=13 (moves most)
                            var maxScrollSteps = totalLayers - 1; // 13
                            var scrollRatio = (stepsFromBottom / maxScrollSteps);
                            scrollRatio = scrollRatio * scrollRatio; // quadratic — L14 compresses most
                            // Pull toward L1's Y position
                            var l1Y = (0 - (totalLayers - 1) / 2) * stackSpacing - 0.15;
                            var scrollPull = (stackY - l1Y) * scrollRatio * scrollCompressAmt;
                            stackY -= scrollPull;
                        }

                        // Problem collapse: L8→L9→L10→...all merge up to L14
                        // L8 starts moving first, L9 follows, etc. All target L14's position.
                        if (problemCollapse.value > 0.001 && gwIdx >= 0 && i >= gwIdx && i < totalLayers - 1) {
                            var numMoving = totalLayers - 1 - gwIdx; // 6 layers move (L8-L13)
                            var stepFromGw = i - gwIdx; // L8=0, L9=1, ..., L13=5
                            // Stagger: L8 starts at 0, L9 at 0.1, L10 at 0.2, etc.
                            var collapseStart = stepFromGw * 0.1;
                            // Duration for each layer to complete its move
                            var collapseDur = 0.4;
                            var snapProgress = Math.max(0, Math.min(1,
                                (problemCollapse.value - collapseStart) / collapseDur));
                            // Cubic ease
                            snapProgress = snapProgress * snapProgress * (3 - 2 * snapProgress);
                            // L14's fixed stack Y
                            var l14StackY = ((totalLayers - 1) - (totalLayers - 1) / 2) * stackSpacing + 0.15;
                            stackY = stackY + (l14StackY - stackY) * snapProgress;
                            // Slight opacity fade as layers merge
                            shellUniforms[i].uOpacity.value *= (1.0 - snapProgress * 0.3);
                        }

                        // Intro expand: override Y during intro animation
                        if (introYTarget > -999) {
                            stackY = introYTarget;
                        }


                        var baseY = stackY * mp;

                        // Y centering: snap disc to vertical center of screen
                        var shouldCenter = (i === activeLayerIndex && rawMorph > 0.15) || (activeGroupMode === 'closing' && mp > 0.5);
                        var targetYCenter = shouldCenter ? (camera.position.y - baseY) : 0;
                        var yLerpSpeed = 0.2;
                        shellYOffsets[i] += (targetYCenter - shellYOffsets[i]) * yLerpSpeed;

                        // X positioning: active disc moves to right side (~10% off-screen), closing stays with group
                        var targetXCenter;
                        if (i === activeLayerIndex && rawMorph > 0.15 && activeGroupMode !== 'closing') {
                            // Work in world space, then convert to group-local
                            var grpScale = autoRotateGroup.scale.x || 1;
                            var grpX = autoRotateGroup.position.x; // usually ~ -2.0

                            // Visible half-width at camera Z (disc is pulled toward camera on Z)
                            var halfWidth = Math.tan(Math.PI * camera.fov / 360) * camera.position.z * camera.aspect;

                            // Disc apparent radius in world space
                            var discR = shellScaleMultipliers[i] * activeLayers[i].r * grpScale;

                            // Target: disc center in world X so 10% of diameter overhangs right edge
                            // rightEdge = halfWidth, disc center = rightEdge - radius + 0.1 * diameter
                            var worldTargetX = halfWidth - discR + discR * 0.2;

                            // Convert world X to group-local X: localX = (worldX - grpX) / grpScale
                            targetXCenter = (worldTargetX - grpX) / grpScale;
                        } else if (shouldCenter && activeGroupMode !== 'closing') {
                            targetXCenter = -autoRotateGroup.position.x;
                        } else {
                            targetXCenter = 0;
                        }
                        shellXOffsets[i] += (targetXCenter - shellXOffsets[i]) * 0.15;

                        mesh.scale.set(scaleXZ, scaleY, scaleXZ);
                        mesh.position.x = shellXOffsets[i];
                        mesh.position.y = baseY + shellYOffsets[i];
                        mesh.position.z = shellZOffsets[i];

                        // === SPHERE FORMATION at peak compression ===
                        // Kicks in at high compression (>60%), fully spherical at 100%
                        if (springCompress > 0.6) {
                            var sphereBlend = Math.min(1, (springCompress - 0.6) / 0.4); // 0→1 over 60%→100%
                            sphereBlend = sphereBlend * sphereBlend; // quadratic ease-in

                            // Y convergence: all layers toward center Y (L8 area)
                            var centerY = 0; // center of stack in group-local
                            mesh.position.y += (centerY - mesh.position.y) * sphereBlend;

                            // X/Z convergence: pull toward center
                            mesh.position.x *= (1 - sphereBlend * 0.8);
                            mesh.position.z *= (1 - sphereBlend * 0.8);

                            // Shape: disc → sphere (scaleY grows to match scaleXZ)
                            var currentXZ = mesh.scale.x;
                            var currentY = mesh.scale.y;
                            mesh.scale.y = currentY + (currentXZ - currentY) * sphereBlend;

                            // Scale equalization: all layers blend toward original concentric radii
                            // (undo the stack flattening, return to natural sphere shell sizes)
                            var sphereR = origR * breathing;
                            mesh.scale.x += (sphereR - mesh.scale.x) * sphereBlend * 0.7;
                            mesh.scale.y += (sphereR - mesh.scale.y) * sphereBlend * 0.7;
                            mesh.scale.z += (sphereR - mesh.scale.z) * sphereBlend * 0.7;

                            // Remove face-camera tilt — return to sphere orientation
                            mesh.rotation.x *= (1 - sphereBlend);
                            mesh.rotation.y *= (1 - sphereBlend);

                        }

                        // === SILICON LAYER GROWTH: L7→L1 scale up with spring tension ===
                        // L1 grows most, L7 grows least, proportional to springCompress
                        if (gwIdx >= 0 && i < gwIdx && springCompress > 0.1) {
                            var stepsFromGW = gwIdx - 1 - i; // 0=L7, 6=L1
                            var maxSteps = gwIdx - 1; // 6 on desktop
                            var growRatio = (stepsFromGW + 1) / (maxSteps + 1); // L7=0.14, L1=1.0
                            var siliconGrow = 1 + springCompress * 0.25 * growRatio;
                            mesh.scale.x *= siliconGrow;
                            mesh.scale.z *= siliconGrow;
                            // Blend Y toward X for rounder shape
                            var sTargetY = mesh.scale.x;
                            mesh.scale.y += (sTargetY - mesh.scale.y) * springCompress * growRatio * 0.5;
                        }

                        // === PER-LAYER MOUSE PARALLAX during spring ===
                        // L14 locked (center), outward layers tilt more with mouse
                        if (springCompress > 0.05) {
                            var l14Idx = activeLayers.length - 1;
                            var distFromCenter = Math.abs(i - l14Idx); // 0=L14, 13=L1
                            var layerParallax = (distFromCenter / l14Idx) * Math.min(1, springCompress * 2);
                            mesh.position.x += pxInput * layerParallax * 0.4;
                            mesh.position.y += -pyInput * layerParallax * 0.3;
                        }

                        // === WHITE RIPPLE WAVE: scroll-driven color pulse through layers ===
                        // Each scroll burst sends a white wave rippling from inner (L14) to outer (L1)
                        if (rippleIntensity > 0.01 && springCompress > 0.3 && shellUniforms[i] && layer.zone !== 'silicon') {
                            // Layer position: 0 = L14 (innermost), 1 = L1 (outermost)
                            var layerPos = (totalLayers - 1 - i) / (totalLayers - 1);
                            // Wave front: wraps so repeated scrolling sends repeated waves
                            var waveFront = (rippleWavePos * 0.8) % 1.4;
                            var dist = Math.abs(layerPos - waveFront);
                            // Also check wrapped distance for smooth looping
                            dist = Math.min(dist, Math.abs(layerPos - waveFront + 1.4));
                            dist = Math.min(dist, Math.abs(layerPos - waveFront - 1.4));
                            // Sharp gaussian-like peak
                            var wave = Math.exp(-dist * dist * 40) * rippleIntensity;

                            // Blend color toward white at wave peak
                            var c = shellUniforms[i].uColor.value;
                            c.x += (1.0 - c.x) * wave * 0.7;
                            c.y += (1.0 - c.y) * wave * 0.7;
                            c.z += (1.0 - c.z) * wave * 0.7;
                            // Boost glow and opacity at wave peak
                            shellUniforms[i].uGlowIntensity.value += wave * 4.0;
                            shellUniforms[i].uOpacity.value += wave * 0.3;
                        }

                        // === TUNNEL / SLINKY ANIMATION ===
                        if (tunnelProgress.value > 0.001) {
                            var tp = tunnelProgress.value;
                            // Stagger: L14 (i=13) enters first, L1 (i=0) enters last
                            var layerDelay = (totalLayers - 1 - i) * 0.055;
                            var lp = Math.max(0, Math.min(1, (tp - layerDelay) / 0.22));
                            lp = lp * lp * (3 - 2 * lp); // smoothstep

                            if (lp > 0.001) {
                                mesh.visible = true;
                                // Depth: L14=0 (entrance, center), L1=1 (deepest, far right)
                                var depth = (totalLayers - 1 - i) / (totalLayers - 1);
                                // Slinky path in group-local coords
                                var slinkyX = Math.pow(depth, 1.3) * 8;
                                var slinkyY = Math.sin(depth * Math.PI * 2.5) * 2.0;
                                var slinkyZ = -depth * 18;
                                // Scale: entrance is large, end is small
                                var tunnelR = origR * (2.5 - depth * 1.6);
                                // Blend position toward slinky target
                                mesh.position.x += (slinkyX - mesh.position.x) * lp;
                                mesh.position.y += (slinkyY - mesh.position.y) * lp;
                                mesh.position.z += (slinkyZ - mesh.position.z) * lp;
                                // Full circle (uniform scale)
                                var ts = tunnelR;
                                mesh.scale.set(
                                    mesh.scale.x + (ts - mesh.scale.x) * lp,
                                    mesh.scale.y + (ts - mesh.scale.y) * lp,
                                    mesh.scale.z + (ts - mesh.scale.z) * lp
                                );
                                // Face camera (tilt 90 degrees on X)
                                mesh.rotation.x += (Math.PI * 0.5 - mesh.rotation.x) * lp;
                                mesh.rotation.y *= (1 - lp);
                                // Opacity
                                shellUniforms[i].uOpacity.value = Math.max(shellUniforms[i].uOpacity.value, lp * 0.9);
                            }
                        }

                        // L14→L9: magenta/teal cycling driven by compression + time
                        // Shared spectrum for all biology layers (L8 has its own)
                        if (gwIdx >= 0 && i > gwIdx) {
                            var mtSpectrum = [
                                [0.90, 0.15, 0.75],  // magenta
                                [0.15, 0.85, 0.85],  // teal
                                [0.95, 0.20, 0.90],  // hot magenta
                                [0.10, 0.75, 0.70],  // deep teal
                                [0.80, 0.25, 0.80],  // purple-magenta
                                [0.20, 0.90, 0.90],  // bright teal
                                [0.90, 0.15, 0.75]   // magenta (loop)
                            ];
                            // Each layer offsets in the cycle so they're not all the same color
                            var stepsFromL14 = (totalLayers - 1) - i; // L14=0, L13=1, ... L9=5
                            var maxSteps = (totalLayers - 1) - gwIdx; // 6
                            var layerPhase = stepsFromL14 / maxSteps * 0.35;
                            // Position: compression + time drift + per-layer offset
                            // L14 cycles faster as spring tension increases
                            var l14SpeedBoost = (stepsFromL14 === 0) ? springCompress * springCompress * 1.5 : 0;
                            var mtPos = (springCompress * 0.6 + t * (0.25 + l14SpeedBoost) + layerPhase) % 1.0;
                            var mtSeg = mtPos * 6;
                            var mtIdx = Math.min(5, Math.floor(mtSeg));
                            var mtFrac = mtSeg - mtIdx;
                            mtFrac = mtFrac * mtFrac * (3 - 2 * mtFrac); // smoothstep
                            var m0 = mtSpectrum[mtIdx], m1 = mtSpectrum[mtIdx + 1];
                            var mtR = m0[0] + (m1[0] - m0[0]) * mtFrac;
                            var mtG = m0[1] + (m1[1] - m0[1]) * mtFrac;
                            var mtB = m0[2] + (m1[2] - m0[2]) * mtFrac;
                            var bc = activeLayers[i].c;
                            var blend = Math.min(1, springCompress * 1.5);
                            shellUniforms[i].uColor.value.set(
                                bc[0] + (mtR - bc[0]) * blend,
                                bc[1] + (mtG - bc[1]) * blend,
                                bc[2] + (mtB - bc[2]) * blend
                            );
                            // L14 glow pulse speeds up with tension
                            if (stepsFromL14 === 0 && springCompress > 0.3) {
                                var l14PulseSpeed = 2.0 + springCompress * springCompress * 6.0;
                                var l14Pulse = 0.5 + 0.5 * Math.sin(t * l14PulseSpeed);
                                shellUniforms[i].uGlowIntensity.value += l14Pulse * (1.0 + springCompress * 1.5);
                                shellUniforms[i].uActiveGlow.value = Math.max(shellUniforms[i].uActiveGlow.value, l14Pulse * springCompress * 0.4);
                            }
                        }

                        // L8 intro: start white, transition to base color
                        if (isGW && introActive) {
                            var whitePhase = Math.max(0, 1 - introVal * 3.0);
                            whitePhase = whitePhase * whitePhase;
                            var bc = activeLayers[i].c;
                            shellUniforms[i].uColor.value.set(
                                bc[0] + (1.0 - bc[0]) * whitePhase,
                                bc[1] + (1.0 - bc[1]) * whitePhase,
                                bc[2] + (1.0 - bc[2]) * whitePhase
                            );
                            shellUniforms[i].uGlowIntensity.value = 2.5 + whitePhase * 3.0;
                        }

                        // (Hover glow removed for hero)

                        // L8 spring: scale up toward perfect circle + cycling spectrum
                        if (isGW && springCompress > 0.01) {
                            // Scale grows with compression — larger the more you scroll
                            var l8SpringGrow = 1 + springCompress * 0.35;
                            mesh.scale.x *= l8SpringGrow;
                            mesh.scale.z *= l8SpringGrow;
                            // Y scale: blend toward matching X/Z so disc becomes perfect circle
                            var targetY = mesh.scale.x; // match width for circle
                            mesh.scale.y += (targetY - mesh.scale.y) * springCompress;
                            // Full spectrum cycle: compression sets base position, time adds drift
                            // 8 vibrant stops that loop — always moving, never static
                            var l8Spectrum = [
                                [0.90, 0.15, 0.75],  // magenta
                                [0.15, 0.85, 0.85],  // teal
                                [0.95, 0.20, 0.90],  // hot magenta
                                [0.10, 0.75, 0.70],  // deep teal
                                [0.80, 0.25, 0.80],  // purple-magenta
                                [0.20, 0.90, 0.90],  // bright teal
                                [0.90, 0.15, 0.75]   // magenta (loop)
                            ];
                            // Position driven by compression + time drift scaled by rotation speed
                            var l8SpinSpeed = (springCompress > 1.0) ? Math.min(1, (springCompress - 1.0) / 0.3) * 0.4 : 0;
                            var l8Pos = (springCompress * 0.7 + t * (0.3 + l8SpinSpeed * 2.5)) % 1.0;
                            var l8Seg = l8Pos * 6; // 6 segments between 7 stops
                            var l8Idx = Math.min(5, Math.floor(l8Seg));
                            var l8Frac = l8Seg - l8Idx;
                            // Smooth interpolation
                            l8Frac = l8Frac * l8Frac * (3 - 2 * l8Frac);
                            var s0 = l8Spectrum[l8Idx], s1 = l8Spectrum[l8Idx + 1];
                            var sr = s0[0] + (s1[0] - s0[0]) * l8Frac;
                            var sg = s0[1] + (s1[1] - s0[1]) * l8Frac;
                            var sb = s0[2] + (s1[2] - s0[2]) * l8Frac;
                            var baseC = activeLayers[i].c;
                            var blend = Math.min(1, springCompress * 1.5);
                            shellUniforms[i].uColor.value.set(
                                baseC[0] + (sr - baseC[0]) * blend,
                                baseC[1] + (sg - baseC[1]) * blend,
                                baseC[2] + (sb - baseC[2]) * blend
                            );
                            shellUniforms[i].uGlowIntensity.value = 2.5 + springCompress * 2.0;
                        }

                        // Easter egg: all layers except L14 scale up exponentially
                        // Distance from L14 determines how much bigger each layer grows
                        if (easterEggPhase > 0.01 && i < totalLayers - 1) {
                            var distFromL14 = (totalLayers - 1) - i; // 1=L13, 13=L1
                            // Exponential: each step away from L14 grows more
                            var expScale = Math.pow(distFromL14 / (totalLayers - 1), 0.6);
                            var growFactor = 1 + expScale * 2.5 * easterEggPhase;
                            mesh.scale.x *= growFactor;
                            mesh.scale.z *= growFactor;
                        }

                        // Face camera: tilt 90° on X to show circle face + counter-rotate
                        if (faceAmt > 0.01) {
                            var tiltX = Math.PI * 0.5 * faceAmt; // 0→90° tilt to face camera
                            mesh.rotation.x = tiltX + (-autoRotateGroup.rotation.x - parallaxGroup.rotation.x) * faceAmt;
                            mesh.rotation.y = (-autoRotateGroup.rotation.y - parallaxGroup.rotation.y) * faceAmt;
                        } else {
                            // Hero: orbital spin per layer — visible gradient rotation
                            // Each layer spins on Y at a different speed, alternating direction
                            var spinDir = (i % 2 === 0) ? 1 : -1;
                            var layerNorm = i / (totalLayers - 1);
                            var spinSpeed = 0.03 + layerNorm * 0.05; // gentle orbital drift
                            mesh.rotation.y = t * spinSpeed * spinDir;
                            // Snap X rotation back to 0 when returning to hero
                            mesh.rotation.x *= 0.9;
                        }

                        // L8 spin: X-axis rotation only after sphere fully forms
                        if (isGW && springCompress > 1.0) {
                            var spinAmt = Math.min(1, (springCompress - 1.0) / 0.3);
                            mesh.rotation.x = t * 0.4 * spinAmt;
                        }

                        // Progressive reveal opacity: L7→L1 — use whichever is stronger (scroll or spring)
                        var revealOpacity = 1.0;
                        if (gwIdx >= 0 && i < gwIdx) {
                            var stepsBelow = gwIdx - 1 - i; // 0=L7, 6=L1
                            // Scroll-down fade
                            var scrollStart = 0.05 + stepsBelow * 0.10;
                            var scrollEnd = scrollStart + 0.12;
                            var scrollReveal = Math.max(0, Math.min(1, (rawMorph - scrollStart) / (scrollEnd - scrollStart)));
                            // Spring tension fade
                            var springStart = 0.08 + stepsBelow * 0.12;
                            var springEnd = springStart + 0.10;
                            var springReveal = Math.max(0, Math.min(1, (springCompress - springStart) / (springEnd - springStart)));
                            // Use whichever reveals more
                            revealOpacity = Math.max(scrollReveal, springReveal);
                            revealOpacity = revealOpacity * revealOpacity * (3 - 2 * revealOpacity);
                        }

                        // Per-layer brightness: scrollBrightness cascades L14→L1
                        // stepsFromTop: 0=L14 (restores first), 13=L1 (restores last)
                        var lastIdx = activeLayers.length - 1;
                        var stepsFromTop = lastIdx - i;
                        // How bright is this layer? scrollBrightness counts layers restored
                        var layerBright = Math.min(1, Math.max(0, scrollBrightness - stepsFromTop));
                        // Start at 50% opacity, ramp to full. Boost targetOpacity for restored layers.
                        var dimmedOpacity = targetOpacity * revealOpacity * (0.5 + layerBright * 0.5) + layerBright * 0.3 * revealOpacity;
                        // Also boost glow intensity as layer restores
                        var scrollGlowBoost = layerBright * 0.4;
                        shellUniforms[i].uOpacity.value +=
                            (dimmedOpacity - shellUniforms[i].uOpacity.value) * 0.2;

                        // All layers: synced white glow pulse + ripple breathing on hero
                        var heroBreathing = (springCompress < 0.01 && !introActive);
                        if (heroBreathing) {
                            // Staggered white pulse: cascades from L14 (top) down to L1 (bottom)
                            var stepsFromTop = (totalLayers - 1) - i; // 0=L14, 13=L1
                            var wavePhase = stepsFromTop * 0.4;
                            var glowPulse = (Math.sin(t * 0.6 - wavePhase) + 1) * 0.5;
                            glowPulse = glowPulse * glowPulse; // sharpen: mostly base color, brief white
                            glowPulse *= 0.35; // cap low for subtle warmth
                            // L13: use L14's color faded toward white instead of own base
                            var l14i = activeLayers.length - 1;
                            var l13i = l14i - 1;
                            var bcc;
                            if (i === l13i) {
                                // L13: faded version of L14's color
                                var l14c = activeLayers[l14i].c;
                                bcc = [
                                    l14c[0] + (1.0 - l14c[0]) * 0.5,
                                    l14c[1] + (1.0 - l14c[1]) * 0.5,
                                    l14c[2] + (1.0 - l14c[2]) * 0.5
                                ];
                            } else if (layer.zone === 'gateway') {
                                // L8: flash glow between blue and teal
                                var l8Cycle = (Math.sin(t * 0.25) + 1.0) * 0.5; // 0→1 smooth
                                var l8Blue = [0.15, 0.35, 0.85];
                                var l8Teal = [0.10, 0.55, 0.60];
                                bcc = [
                                    l8Teal[0] + (l8Blue[0] - l8Teal[0]) * l8Cycle,
                                    l8Teal[1] + (l8Blue[1] - l8Teal[1]) * l8Cycle,
                                    l8Teal[2] + (l8Blue[2] - l8Teal[2]) * l8Cycle
                                ];
                            } else {
                                bcc = activeLayers[i].c;
                            }
                            var gp = (layer.zone === 'gateway') ? 0 : glowPulse;
                            // Color intensity wave: cascades top→bottom then back up
                            var wavePos = (Math.sin(t * 0.3) + 1.0) * 0.5 * (totalLayers - 1); // bounces 0→13
                            var waveDist = Math.abs(i - wavePos);
                            var colorBoost = Math.max(0, 1.0 - waveDist * 0.25); // wide gradient
                            colorBoost = colorBoost * 0.6; // intensity multiplier
                            var isGateway = (layer.zone === 'gateway');
                            var cb = isGateway ? 0 : colorBoost;
                            // Boost: push color toward itself (more saturated) + slight brightness
                            shellUniforms[i].uColor.value.set(
                                bcc[0] + (1.0 - bcc[0]) * gp + (bcc[0] - 0.5) * cb * 0.5,
                                bcc[1] + (1.0 - bcc[1]) * gp + (bcc[1] - 0.5) * cb * 0.5,
                                bcc[2] + (1.0 - bcc[2]) * gp + (bcc[2] - 0.5) * cb * 0.5
                            );
                            shellUniforms[i].uGlowIntensity.value = 1.5 + glowPulse * 2.0 + cb * 1.5;
                            shellUniforms[i].uOpacity.value = 0.6 + glowPulse * 0.2 + cb * 0.15;

                            // L14 + L8: drive uActiveGlow for electric pool shader effect
                            if (i === l14i || layer.zone === 'gateway') {
                                shellUniforms[i].uActiveGlow.value = 0.3 + glowPulse * 0.4;
                            }

                            // Pool ripple: gentle scale pulse per layer
                            var ripplePhase = i * 0.45;
                            var ripple1 = Math.sin(t * 0.5 - ripplePhase) * 0.004;
                            var ripple2 = Math.sin(t * 0.8 - ripplePhase * 1.3) * 0.002;
                            var rippleScale = 1.0 + ripple1 + ripple2;
                            mesh.scale.x *= rippleScale;
                            mesh.scale.z *= rippleScale;

                            // Accordion Y breathing: exponential — top layers compress most
                            var layerRatio = i / (totalLayers - 1); // 0=L1(bottom), 1=L14(top)
                            var expCompress = Math.pow(layerRatio, 2.5); // exponential: bottom ~0, top ~1
                            var accPhase = i * 0.35;
                            var accBreathAmp = (0.012 + expCompress * 0.16);
                            var accBreath = Math.sin(t * 0.4 - accPhase) * accBreathAmp;
                            mesh.position.y += accBreath;

                            // Track total stack compression distance this frame
                            // Sum all layers' absolute Y displacement for color speed
                            if (typeof window._accTotalDelta === 'undefined') {
                                window._accTotalDelta = 0;
                                window._accPrevSum = 0;
                            }
                            if (typeof window._accFrameSum === 'undefined') window._accFrameSum = 0;
                            window._accFrameSum += Math.abs(accBreath);
                            if (i === totalLayers - 1) {
                                window._accTotalDelta = Math.abs(window._accFrameSum - window._accPrevSum);
                                window._accPrevSum = window._accFrameSum;
                                window._accFrameSum = 0;
                            }

                            // Scale breathing: bottom layers scale up as top layers compress down
                            // Inverse ratio: L1 scales most (1.0), L14 scales least (0.0)
                            var invRatio = 1.0 - layerRatio;
                            // Scale proportional to this layer's compression displacement
                            var compressAmt = Math.abs(accBreath) / 0.30; // normalize to max amplitude
                            var scaleBoost = 1.0 + (1.0 - compressAmt) * invRatio * 0.06;
                            mesh.scale.x *= scaleBoost;
                            mesh.scale.z *= scaleBoost;

                        }

                        // (L13 tracking moved inside heroBreathing block)

                        // Active/hover glow lerp
                        var glowTarget;
                        if (i === activeLayerIndex && isGW) {
                            // L8 flamboyant: intense pulsing glow
                            glowTarget = 1.5 + Math.sin(t * 5.0) * 0.5;
                        } else if (i === activeLayerIndex) {
                            glowTarget = 1.0;
                        } else if (i === hoveredShellIndex && activeGroupMode === null) {
                            glowTarget = 0.45;
                        } else {
                            glowTarget = 0.0;
                        }

                        // Intro ripple cascade: L14 lights up first, then L13→L8, then L7→L1
                        var isBioOrGW = (layer.zone === 'biology' || layer.zone === 'gateway');
                        var introRippling = (bangProgress > 0.05 && bangProgress < 0.99 && activeLayerIndex < 0 && activeGroupMode !== 'closing');
                        if (introRippling) {
                            var lastIdx = activeLayers.length - 1; // L14 = topmost
                            var totalLayers = activeLayers.length;

                            // Stagger order: L14 first (index 13), down to L8 (index 7), then L7→L1
                            var stepsFromTop;
                            if (isBioOrGW) {
                                stepsFromTop = lastIdx - i; // 0 for L14, 6 for L8
                            } else {
                                // Silicon: continue after all bio layers, L7 first then L1 last
                                var bioCount = lastIdx - gwIdx + 1; // 7 bio/gw layers
                                stepsFromTop = bioCount + (gwIdx - 1 - i); // L7=7, L6=8... L1=13
                            }

                            var layerStart = 0.08 + (stepsFromTop / totalLayers) * 0.7;
                            var layerRamp = (bangProgress - layerStart) / 0.12;
                            var chargeAmt = Math.max(0, Math.min(1, layerRamp));

                            // Ripple scale: incremental per layer — L1 largest, L14 smallest
                            // layerRank: 0 for L14 (top), 13 for L1 (bottom/outermost)
                            var layerRank = (lastIdx - i);
                            var maxBoost = 0.05 + (1 - layerRank / lastIdx) * 0.25; // L1=0.30, L14=0.05
                            var ripplePeak = Math.max(0, Math.min(1, (bangProgress - layerStart) / 0.08));
                            var rippleDecay = Math.max(0, Math.min(1, (bangProgress - layerStart - 0.08) / 0.20));
                            var rippleScale = ripplePeak * (1 - rippleDecay); // peaks then returns to 1.0
                            shellScaleMultipliers[i] = Math.max(shellScaleMultipliers[i], 1.0 + rippleScale * maxBoost);

                            // Vibrancy boost: subtle — enough to brighten without washing white
                            var glowBoost = isBioOrGW ? chargeAmt * 0.6 : chargeAmt * 0.3;
                            shellUniforms[i].uGlowIntensity.value = 1.2 + glowBoost;

                            glowTarget = Math.max(glowTarget, chargeAmt * 0.35);
                        } else {
                            // Once fully flattened (scroll morph done), L14→L8 pulse breathing
                            var morphDone = rawMorph > 0.25;
                            var defaultGlow = isGW ? 2.5 : 1.2;
                            if (isBioOrGW && morphDone && activeLayerIndex < 0 && activeGroupMode !== 'closing') {
                                var lastIdx = activeLayers.length - 1;
                                var stepsFromTop = lastIdx - i; // 0=L14, 6=L8
                                // Each layer pulses with a phase offset so L14 peaks first, then L13...
                                var phaseOffset = stepsFromTop * 0.9; // ~0.9 rad apart
                                var pulseSin = Math.sin(t * 2.0 - phaseOffset);
                                // pulseSin -1→1, map to 0→1 for opacity/vibrancy boost
                                var pulseAmt = pulseSin * 0.5 + 0.5; // 0→1

                                // Opacity pulse: base + subtle swing
                                targetOpacity = Math.max(targetOpacity, 0.4 + pulseAmt * 0.2);
                                // Vibrancy pulse: gentle swing, stays colorful not white
                                shellUniforms[i].uGlowIntensity.value = defaultGlow + pulseAmt * 0.5;
                                // ActiveGlow pulse: kept low to avoid white wash
                                glowTarget = Math.max(glowTarget, pulseAmt * 0.2);
                            } else if (i === activeLayerIndex && isGW) {
                                // L8 flamboyant: intense pulsing glow intensity
                                var gwGlowPulse = 4.0 + Math.sin(t * 6.0) * 1.5;
                                shellUniforms[i].uGlowIntensity.value += (gwGlowPulse - shellUniforms[i].uGlowIntensity.value) * 0.1;
                            } else if (!heroBreathing) {
                                var targetGI = defaultGlow + scrollGlowBoost;
                                shellUniforms[i].uGlowIntensity.value += (targetGI - shellUniforms[i].uGlowIntensity.value) * 0.08;
                            }
                        }

                        // Glow lerp (skip during closing and hero breathing — they manage glow directly)
                        if (activeGroupMode !== 'closing' && !heroBreathing) {
                            var introRippleActive = (isBioOrGW && bangProgress > 0.05 && bangProgress < 0.99 && activeLayerIndex < 0 && activeGroupMode !== 'closing');
                            var glowLerpIn = introRippleActive ? 0.12 : 0.03;
                            var glowLerp = (glowTarget > shellUniforms[i].uActiveGlow.value) ? glowLerpIn : 0.06;
                            shellUniforms[i].uActiveGlow.value +=
                                (glowTarget - shellUniforms[i].uActiveGlow.value) * glowLerp;
                        }

                        // Spring egg: L14 + neighbors glow vibrant red, spreading with eggBlend
                        if (springEggActive) {
                            var eggBlend = Math.min(1, (springCompress - 1.95) / 0.05);
                            var eggPulse = 0.5 + 0.5 * Math.sin(t * 5.0);
                            var l14i = activeLayers.length - 1;
                            // How many layers from L14 should glow red (0=just L14, up to 5 at full)
                            var redSpread = Math.floor(eggBlend * 5);
                            var distFromL14 = l14i - i;
                            if (distFromL14 >= 0 && distFromL14 <= redSpread) {
                                var falloff = 1.0 - (distFromL14 / (redSpread + 1)) * 0.6;
                                var whiteAmt = eggBlend * falloff;
                                if (distFromL14 === 0) {
                                    // L14: override to pulsating white glow
                                    shellUniforms[i].uColor.value.x = 0.9 + eggPulse * 0.1;
                                    shellUniforms[i].uColor.value.y = 0.9 + eggPulse * 0.1;
                                    shellUniforms[i].uColor.value.z = 0.95 + eggPulse * 0.05;
                                    shellUniforms[i].uOpacity.value = 0.7 + eggBlend * 0.3;
                                    shellUniforms[i].uGlowIntensity.value = 3.5 + eggPulse * 2.5;
                                    shellUniforms[i].uActiveGlow.value = 0.5 + eggPulse * 0.5;
                                } else {
                                    // Neighbors blend toward white
                                    shellUniforms[i].uColor.value.x += (1.0 - shellUniforms[i].uColor.value.x) * whiteAmt;
                                    shellUniforms[i].uColor.value.y += (1.0 - shellUniforms[i].uColor.value.y) * whiteAmt;
                                    shellUniforms[i].uColor.value.z += (1.0 - shellUniforms[i].uColor.value.z) * whiteAmt;
                                    shellUniforms[i].uOpacity.value = Math.min(shellUniforms[i].uOpacity.value + whiteAmt * 0.15, 1.0);
                                    shellUniforms[i].uGlowIntensity.value = Math.max(shellUniforms[i].uGlowIntensity.value, (3.0 + eggPulse * 2.0) * whiteAmt);
                                    shellUniforms[i].uActiveGlow.value = Math.max(shellUniforms[i].uActiveGlow.value, (0.4 + eggPulse * 0.5) * whiteAmt);
                                }
                            }
                        }

                        // Rainbow ripple: spectrum wave radiates outward from L14 after egg disappears
                        if (rainbowRippleTime > 0 && shellUniforms[i]) {
                            var rippleAge = t - rainbowRippleTime;
                            var rippleDuration = 3.0; // seconds
                            if (rippleAge < rippleDuration) {
                                var totalLrs = activeLayers.length;
                                var layerPos = (totalLrs - 1 - i) / (totalLrs - 1); // 0=L14(center), 1=L1(outer)
                                // Wave front expands outward from center over time
                                var waveFront = rippleAge / rippleDuration * 1.4;
                                var dist = Math.abs(layerPos - waveFront);
                                var wave = Math.exp(-dist * dist * 25) * Math.max(0, 1 - rippleAge / rippleDuration);
                                // Hue cycles through spectrum based on layer position + time
                                var hue = (layerPos * 0.8 + rippleAge * 0.5) % 1.0;
                                // HSV to RGB (s=1, v=1)
                                var hi = Math.floor(hue * 6);
                                var f = hue * 6 - hi;
                                var q = 1 - f;
                                var rr, gg, bb;
                                switch (hi % 6) {
                                    case 0: rr=1; gg=f; bb=0; break;
                                    case 1: rr=q; gg=1; bb=0; break;
                                    case 2: rr=0; gg=1; bb=f; break;
                                    case 3: rr=0; gg=q; bb=1; break;
                                    case 4: rr=f; gg=0; bb=1; break;
                                    case 5: rr=1; gg=0; bb=q; break;
                                }
                                var c = shellUniforms[i].uColor.value;
                                c.x += (rr - c.x) * wave * 0.85;
                                c.y += (gg - c.y) * wave * 0.85;
                                c.z += (bb - c.z) * wave * 0.85;
                                shellUniforms[i].uGlowIntensity.value += wave * 3.0;
                                shellUniforms[i].uOpacity.value = Math.min(shellUniforms[i].uOpacity.value + wave * 0.2, 1.0);
                            }
                        }

                        // (Old hover ripple removed — replaced by inline hover glow above)

                        // Position laser-etched label to match disc
                        var lm = labelMeshes[i];
                        lm.position.x = mesh.position.x;
                        lm.position.y = mesh.position.y + 0.03;
                        lm.position.z = mesh.position.z;
                        // Offset -PI/2 on X so plane lies in XZ (flat on disc surface)
                        lm.rotation.x = mesh.rotation.x - Math.PI * 0.5;
                        lm.rotation.y = mesh.rotation.y;
                        lm.rotation.z = mesh.rotation.z;
                        // Scale label to fit inside disc
                        var labelScale = scaleXZ * 0.82;
                        lm.scale.set(labelScale, labelScale, 1);
                        // Fade in with cubic ease — text appears after disc mostly faces camera
                        // Hide labels during OSI group and closing mode
                        var hideLabel = activeGroupMode === 'closing' || introActive;
                        var labelOpacity = hideLabel ? 0 : Math.pow(Math.max(0, faceAmt - 0.3) / 0.7, 2.5) * 0.85;
                        lm.material.opacity = labelOpacity;
                    }

                    // Hide labels in sphere mode
                    if (mp < 0.01) {
                        var lm = labelMeshes[i];
                        lm.material.opacity = 0;
                    }
                });

                // Hover: subtle glow/expand + tooltip (click triggers full pull-out)
                if (canvasInteractive && rawMorph > 0.15 && introProgress.value > 0.95 && activeGroupMode !== 'closing' && closingShrink.value < 0.05 && tunnelProgress.value < 0.05) {
                    raycaster.setFromCamera(rayMouse, camera);
                    var hoverHits = raycaster.intersectObjects(shellMeshes);
                    hoveredShellIndex = (hoverHits.length > 0) ? shellMeshes.indexOf(hoverHits[0].object) : -1;

                    // Tooltip: show zone tag + layer name + click action when hovering any layer
                    if (hoveredShellIndex >= 0) {
                        var hLayer = activeLayers[hoveredShellIndex];
                        hoverTooltipId.textContent = hLayer.id;
                        var hData = layerData[hLayer.id];
                        hoverTooltipName.textContent = hData ? hData.name : '';
                        hoverTooltipAction.textContent = (hoveredShellIndex === activeLayerIndex) ? 'Click to collapse' : 'Click to expand';
                        // Zone color tag: OSI (silicon L1-L7), Gateway (L8), ONI (biology L9-L14)
                        var zoneLabel = hLayer.zone === 'silicon' ? 'OSI' : 'ONI';
                        var zoneClass = hLayer.zone === 'silicon' ? 'zone-osi' : (hLayer.zone === 'gateway' ? 'zone-gateway' : 'zone-oni');
                        hoverTooltipZone.textContent = zoneLabel;
                        hoverTooltipZone.className = 'hover-tooltip-zone ' + zoneClass;
                        hoverTooltip.style.left = (lastMouseClientX + 16) + 'px';
                        hoverTooltip.style.top = (lastMouseClientY - 12) + 'px';
                        hoverTooltip.classList.add('visible');
                        hasInteracted = true;
                    } else {
                        hoverTooltip.classList.remove('visible');
                    }

                    document.body.style.cursor = (hoveredShellIndex >= 0) ? 'pointer' : '';
                } else if (introProgress.value > 0.95 && activeGroupMode !== 'closing' && tunnelProgress.value < 0.05) {
                    // Hero/spring scene: no hover interaction
                    hoveredShellIndex = -1;
                    hoverTooltip.classList.remove('visible');
                } else {
                    hoveredShellIndex = -1;
                    hoverTooltip.classList.remove('visible');
                    if (canvasInteractive) document.body.style.cursor = '';
                }

                // Click hint: only visible when full stack is showing and not collapsing
                var showHint = canvasInteractive && !hasInteracted && rawMorph > 0.25 && closingShrink.value < 0.05 && tunnelProgress.value < 0.05 && activeLayerIndex === -1 && activeGroupMode !== 'closing';
                if (showHint) {
                    clickHint.classList.add('visible');
                } else {
                    clickHint.classList.remove('visible');
                }

                // Stack-fit scale: shrink the stack so all 14 layers fit in viewport
                // Use effectiveMorph so it applies during both intro and scroll
                var stackFitScale = 1 - effectiveMorph * 0.22;
                // ONI shrink: scale down AFTER face-tilt is mostly done (delayed start)
                var shrinkVal = Math.max(0, (closingShrink.value - 0.5) / 0.5); // 0 until 50% tilt, then ramps to 1
                var closingShrinkScale = 1 - shrinkVal * 0.6; // 1.0 → 0.4
                // Tunnel + hero slinky: restore scale back toward 1
                // Tunnel: restore scale back toward 1
                if (tunnelProgress.value > 0.01) {
                    closingShrinkScale += (1 - closingShrinkScale) * tunnelProgress.value;
                    stackFitScale += (1 - stackFitScale) * tunnelProgress.value;
                }
                var finalGroupScale = stackFitScale * closingShrinkScale;
                autoRotateGroup.scale.setScalar(finalGroupScale);

                // ONI closing: merged disc = "O", HTML "NI" overlay fades in, then both center
                if (activeGroupMode === 'closing') {
                    // Phase 1: "NI" fades in after convergence (closingPhase > 0.6)
                    var niFadeTarget = (closingPhase > 0.6) ? 1.0 : 0.0;
                    niOpacity += (niFadeTarget - niOpacity) * 0.06;

                    // Project disc center (shell 0) to screen coordinates
                    // Update world matrix to include latest position changes this frame
                    shellMeshes[0].updateWorldMatrix(true, false);
                    niProjection.setFromMatrixPosition(shellMeshes[0].matrixWorld);
                    var discWorldZ = niProjection.z; // save before projection
                    var discWorldScale = shellMeshes[0].scale.x * (autoRotateGroup.scale.x || 1);
                    niProjection.project(camera);
                    var discScreenX = (niProjection.x * 0.5 + 0.5) * window.innerWidth;
                    var discScreenY = (-niProjection.y * 0.5 + 0.5) * window.innerHeight;

                    // Compute disc apparent size for proportional NI sizing and offset
                    var camDist = Math.max(0.1, camera.position.z - discWorldZ);
                    var discScreenRadius = (discWorldScale / (2 * camDist * Math.tan(Math.PI * camera.fov / 360))) * window.innerHeight * 0.5;

                    // NI font size = disc diameter so letter height matches "O" (the disc)
                    var discDiameter = discScreenRadius * 2;
                    var niFontSize = discDiameter * 0.82; // cap-height ≈ 0.72× font-size, so 0.82 makes cap ≈ disc diameter

                    // Letter gap: consistent spacing between O-N and N-I
                    var letterGap = discDiameter * 0.08;

                    // NI left edge starts far right, slides to just past disc right edge
                    var discRightEdge = discScreenX + discScreenRadius;
                    var niFinalX = discRightEdge + letterGap;
                    var niStartX = discRightEdge + discDiameter * 1.2;
                    var niLeftX = niStartX + (niFinalX - niStartX) * niSlidePhase;

                    niOverlay.style.left = niLeftX + 'px';
                    niOverlay.style.top = discScreenY + 'px';
                    niOverlay.style.fontSize = niFontSize + 'px';
                    niOverlay.style.letterSpacing = letterGap + 'px';
                    niOverlay.style.opacity = niOpacity;
                } else {
                    niOpacity += (0 - niOpacity) * 0.12;
                    niOverlay.style.opacity = niOpacity;
                }

                // === INTRO SEQUENCE: cascade → text emerges from L8 ===
                if (!window._introSeqStarted && introProgress.value > 0.95) {
                    window._introSeqStarted = true;
                    window._introSeqTime = t;
                }
                if (window._introSeqStarted && !window._introSeqDone) {
                    var seqT = t - window._introSeqTime;
                    var l14Idx = activeLayers.length - 1;
                    var numBioLayers = l14Idx - gwIdxGlobal; // L8 to L14

                    // Phase 0: L14 glows gold — gentle pulse
                    var l14BaseScale = activeLayers[l14Idx].r;
                    if (seqT < 0.8) {
                        var goldPulse = (Math.sin(seqT * 5.0) + 1.0) * 0.5 * (1.0 - seqT / 0.8);
                        var l14c = shellUniforms[l14Idx].uColor.value;
                        l14c.set(
                            l14c.x + (0.95 - l14c.x) * goldPulse * 0.7,
                            l14c.y + (0.80 - l14c.y) * goldPulse * 0.7,
                            l14c.z + (0.15 - l14c.z) * goldPulse * 0.7
                        );
                        shellUniforms[l14Idx].uGlowIntensity.value = 2.0 + goldPulse * 6.0;
                        shellUniforms[l14Idx].uOpacity.value = 0.5 + goldPulse * 0.4;
                        if (shellUniforms[l14Idx].uBubbleMix) {
                            shellUniforms[l14Idx].uBubbleMix.value = 0.80 * (1.0 - goldPulse * 0.6);
                        }
                        // Gentle breath on XZ (multiply, don't override)
                        var expandMult = 1.0 + goldPulse * 0.1;
                        shellMeshes[l14Idx].scale.x *= expandMult;
                        shellMeshes[l14Idx].scale.z *= expandMult;
                    } else if (seqT < 1.1) {
                        if (shellUniforms[l14Idx].uBubbleMix) {
                            shellUniforms[l14Idx].uBubbleMix.value += (0.80 - shellUniforms[l14Idx].uBubbleMix.value) * 0.1;
                        }
                    }

                    // Phase 1: Color cycle cascade L14 → L8
                    var magentaStart = 0.8; // start after gold pulse
                    // Color cycle palette: each layer rapidly cycles through all colors during its flash
                    var cycleColors = [
                        [0.85, 0.15, 0.75],  // magenta
                        [0.85, 0.70, 0.20],  // gold
                        [0.15, 0.80, 0.75],  // teal
                        [0.25, 0.40, 0.90],  // blue
                        [0.65, 0.30, 0.85],  // purple
                        [0.55, 0.85, 0.55]   // pastel green
                    ];
                    for (var mi = l14Idx; mi >= gwIdxGlobal; mi--) {
                        var mDelay = magentaStart + (l14Idx - mi) * 0.15;
                        var mAge = seqT - mDelay;
                        if (mAge > 0 && mAge < 0.8) {
                            var mInt = Math.sin(mAge / 0.8 * Math.PI);
                            // Rapid cycle through all 5 colors during flash
                            var cyclePos = (mAge / 0.8) * cycleColors.length; // cycles through all colors
                            var cLow = Math.floor(cyclePos) % cycleColors.length;
                            var cHigh = (cLow + 1) % cycleColors.length;
                            var cFrac = cyclePos - Math.floor(cyclePos);
                            var cr = cycleColors[cLow][0] + (cycleColors[cHigh][0] - cycleColors[cLow][0]) * cFrac;
                            var cg = cycleColors[cLow][1] + (cycleColors[cHigh][1] - cycleColors[cLow][1]) * cFrac;
                            var cb = cycleColors[cLow][2] + (cycleColors[cHigh][2] - cycleColors[cLow][2]) * cFrac;
                            var mc = shellUniforms[mi].uColor.value;
                            mc.set(
                                mc.x + (cr - mc.x) * mInt,
                                mc.y + (cg - mc.y) * mInt,
                                mc.z + (cb - mc.z) * mInt
                            );
                            shellUniforms[mi].uGlowIntensity.value += mInt * 5.0;
                            shellUniforms[mi].uOpacity.value = Math.min(1.0, shellUniforms[mi].uOpacity.value + mInt * 0.5);
                            // Breathing: multiply current XZ scale (don't override)
                            var breathMult = 1.0 + mInt * 0.06;
                            shellMeshes[mi].scale.x *= breathMult;
                            shellMeshes[mi].scale.z *= breathMult;
                            // Y stays unchanged — keep disc flat on same plane
                            // Magenta point light on L14 during its flash
                            if (mi === l14Idx && !window._introMagLight) {
                                window._introMagLight = new THREE.PointLight(0xdd11dd, 0, 8);
                                scene.add(window._introMagLight);
                            }
                            if (mi === l14Idx && window._introMagLight) {
                                window._introMagLight.position.copy(shellMeshes[l14Idx].position);
                                window._introMagLight.intensity = mInt * 4.0;
                            }
                        }
                    }

                    // Quote overlay: fade in during gold pulse, hold during cascade, fade out before text
                    // Timeline: fade in 0→0.6s, hold 0.6→2.0s, fade out 2.0→2.8s
                    if (seqT < 0.6) {
                        heroQuoteOverlay.style.opacity = (seqT / 0.6);
                    } else if (seqT < 2.0) {
                        heroQuoteOverlay.style.opacity = 1;
                    } else if (seqT < 2.8) {
                        heroQuoteOverlay.style.opacity = 1 - ((seqT - 2.0) / 0.8);
                    } else {
                        heroQuoteOverlay.style.opacity = 0;
                    }

                    // Phase 2: L8 blinks white after cascade reaches it
                    var l8BlinkStart = magentaStart + numBioLayers * 0.15 + 0.8;
                    var l8BlinkAge = seqT - l8BlinkStart;
                    if (l8BlinkAge > 0 && l8BlinkAge < 0.3) {
                        var l8Blink = Math.sin(l8BlinkAge / 0.3 * Math.PI); // single pulse up and down
                        var l8c = shellUniforms[gwIdxGlobal].uColor.value;
                        l8c.set(
                            l8c.x + (1.0 - l8c.x) * l8Blink,
                            l8c.y + (1.0 - l8c.y) * l8Blink,
                            l8c.z + (1.0 - l8c.z) * l8Blink
                        );
                        shellUniforms[gwIdxGlobal].uGlowIntensity.value += l8Blink * 6.0;
                    }

                    // Phase 3: Text emerges from L8, slides down as it fades in
                    var textStart = l8BlinkStart + 0.3;
                    var textAge = seqT - textStart;
                    if (textAge > 0) {
                        // Get L8 screen Y
                        var l8Pos = new THREE.Vector3().setFromMatrixPosition(shellMeshes[gwIdxGlobal].matrixWorld);
                        l8Pos.project(camera);
                        var l8ScrY = (-l8Pos.y * 0.5 + 0.5) * 100;
                        var textStartY = 10; // start near top of page
                        var textEndY = 88; // end below animation
                        var textProgress = Math.min(1, textAge / 2.0); // 2s to reach final position
                        var eased = 1 - Math.pow(1 - textProgress, 3); // ease-out cubic
                        var textY = textStartY + (textEndY - textStartY) * eased;
                        // Fade in: starts transparent, increases opacity as it moves down
                        var containerOpacity = Math.min(1, eased); // opacity follows position progress
                        heroOsiTaglineTop.style.top = textY + '%';
                        heroOsiTaglineTop.style.opacity = containerOpacity;
                        heroOsiTaglineTop.style.transform = 'translate(-50%, -50%)';

                        // Stagger each line within the container
                        var line1P = Math.min(1, Math.max(0, (textAge - 0.3) / 1.0));
                        var line2P = Math.min(1, Math.max(0, (textAge - 0.7) / 1.0));
                        var line3P = Math.min(1, Math.max(0, (textAge - 1.1) / 1.0));
                        heroNeuroLine.style.opacity = line1P;
                        heroNeuroLine.style.transform = 'translateY(' + ((1 - line1P) * -20) + 'px)';
                        heroOsiLine.style.opacity = line2P;
                        heroOsiLine.style.transform = 'translateY(' + ((1 - line2P) * -20) + 'px)';
                        heroAuthorLine.style.opacity = line3P;
                        heroAuthorLine.style.transform = 'translateY(' + ((1 - line3P) * -20) + 'px)';

                        if (textProgress >= 1 && line3P >= 1) {
                            window._introSeqDone = true;
                            // Clean up intro lights
                            if (window._introMagLight) {
                                window._introMagLight.intensity = 0;
                            }
                            // Ensure quote overlay is hidden
                            heroQuoteOverlay.style.opacity = 0;
                            heroQuoteOverlay.style.display = 'none';
                        }
                    }
                }

                // Tagline: slide up toward L8 and fade through it
                var scrollFade = Math.min(1, window.scrollY / 600);
                var taglineFade = Math.max(springCompress * 2, rawMorph * 4, scrollFade);
                if (taglineFade > 0.01 && gwIdxGlobal >= 0 && gwIdxGlobal < shellMeshes.length) {
                    var l8TagPos = new THREE.Vector3().setFromMatrixPosition(shellMeshes[gwIdxGlobal].matrixWorld);
                    l8TagPos.project(camera);
                    var l8ScreenY = (-l8TagPos.y * 0.5 + 0.5) * 100; // as % of viewport
                    var startY = 88;
                    var targetY = l8ScreenY;
                    // Linear slide for most of the journey, only accelerate at end
                    var slideProgress = Math.min(1, taglineFade);
                    var currentY = startY + (targetY - startY) * slideProgress;
                    // Only start fading when close to L8 (last 30% of journey)
                    var fadeStart = 0.6;
                    var taglineOpacity = taglineFade < fadeStart ? 1.0 : Math.max(0, 1 - (taglineFade - fadeStart) / (1 - fadeStart));
                    heroOsiTaglineTop.style.top = currentY + '%';
                    heroOsiTaglineTop.style.transform = 'translate(-50%, -50%)';
                    heroOsiTaglineTop.style.opacity = taglineOpacity;
                    heroOsiTaglineTop.style.display = taglineOpacity < 0.01 ? 'none' : 'block';

                    // Green flash cascade: triggers when text opacity hits ~50%
                    if (!window._greenFlashTriggered && taglineOpacity <= 0.5 && taglineOpacity > 0.01) {
                        window._greenFlashTriggered = true;
                        window._greenFlashTime = t;
                    }
                } else {
                    heroOsiTaglineTop.style.opacity = Math.max(0, 1 - taglineFade);
                    heroOsiTaglineTop.style.top = '88%';
                    heroOsiTaglineTop.style.transform = 'translate(-50%, -50%)';
                    heroOsiTaglineTop.style.display = (1 - taglineFade) < 0.01 ? 'none' : 'block';
                    // Reset flash trigger when scrolled back to top
                    if (taglineFade < 0.1) window._greenFlashTriggered = false;
                }

                // Green flash cascade: L8 first, then L9, L10, etc.
                if (window._greenFlashTriggered && window._greenFlashTime) {
                    var flashElapsed = t - window._greenFlashTime;
                    var greenColor = [0.1, 0.9, 0.3];
                    for (var fi = 0; fi < activeLayers.length; fi++) {
                        var flashDelay = 0;
                        if (fi === gwIdxGlobal) {
                            flashDelay = 0; // L8 first
                        } else if (fi > gwIdxGlobal) {
                            flashDelay = (fi - gwIdxGlobal) * 0.15; // L9, L10... cascade up
                        } else {
                            continue; // skip silicon layers
                        }
                        var flashAge = flashElapsed - flashDelay;
                        if (flashAge > 0 && flashAge < 1.0) {
                            var flashIntensity = Math.sin(flashAge / 1.0 * Math.PI); // rise and fall
                            flashIntensity *= 1.0;
                            var cur = shellUniforms[fi].uColor.value;
                            cur.set(
                                cur.x + (greenColor[0] - cur.x) * flashIntensity,
                                cur.y + (greenColor[1] - cur.y) * flashIntensity,
                                cur.z + (greenColor[2] - cur.z) * flashIntensity
                            );
                            shellUniforms[fi].uGlowIntensity.value += flashIntensity * 5.0;
                            shellUniforms[fi].uOpacity.value = Math.min(1.0, shellUniforms[fi].uOpacity.value + flashIntensity * 0.5);
                        }
                    }
                    // L14 teal blink: starts after green cascade finishes at L14
                    var l14Idx = activeLayers.length - 1;
                    var l14FlashEnd = (l14Idx - gwIdxGlobal) * 0.15 + 1.0; // when L14's green flash ends
                    var blinkStart = flashElapsed - l14FlashEnd;
                    if (blinkStart > 0 && blinkStart < 1.5) {
                        var blinkRate = Math.sin(blinkStart * 25.0); // rapid oscillation
                        var blinkIntensity = Math.max(0, blinkRate) * (1.0 - blinkStart / 1.5); // fade out over 1.5s
                        var tealColor = [0.1, 0.85, 0.8];
                        var l14c = shellUniforms[l14Idx].uColor.value;
                        l14c.set(
                            l14c.x + (tealColor[0] - l14c.x) * blinkIntensity,
                            l14c.y + (tealColor[1] - l14c.y) * blinkIntensity,
                            l14c.z + (tealColor[2] - l14c.z) * blinkIntensity
                        );
                        shellUniforms[l14Idx].uGlowIntensity.value += blinkIntensity * 6.0;
                        shellUniforms[l14Idx].uOpacity.value = Math.min(1.0, shellUniforms[l14Idx].uOpacity.value + blinkIntensity * 0.6);
                        // Magenta outer glow on L14 mesh via CSS filter on canvas
                        var l14Mesh = shellMeshes[l14Idx];
                        if (!window._l14GlowLight) {
                            window._l14GlowLight = new THREE.PointLight(0xff00ff, 0, 8);
                            scene.add(window._l14GlowLight);
                        }
                        window._l14GlowLight.position.copy(l14Mesh.position);
                        window._l14GlowLight.intensity = blinkIntensity * 4.0;
                        window._l14GlowLight.color.setRGB(0.9, 0.1, 0.85); // magenta
                    } else if (window._l14GlowLight) {
                        window._l14GlowLight.intensity *= 0.85; // fade out
                    }
                }

                // Seizure warning: shows at springCompress ~1.0, fades out once dismissed or passed
                if (!seizureWarningDismissed && springCompress > 1.5 && springCompress < 1.95) {
                    var warnBlend = Math.min(1, (springCompress - 1.5) / 0.15);
                    var warnFade = springCompress > 1.8 ? Math.max(0, 1 - (springCompress - 1.8) / 0.15) : 1;
                    seizureWarningEl.style.opacity = warnBlend * warnFade;
                    // Center on screen
                    seizureWarningEl.style.left = '50%';
                    seizureWarningEl.style.top = '60%';
                    if (springCompress > 1.9) seizureWarningDismissed = true;
                } else {
                    var warnCurOp = parseFloat(seizureWarningEl.style.opacity || 0);
                    if (warnCurOp > 0.01) {
                        seizureWarningEl.style.opacity = Math.max(0, warnCurOp * 0.9);
                    }
                }
                // Reset dismissed flag when spring fully releases
                if (springCompress < 0.2) seizureWarningDismissed = false;

                // Spring art overlay: fades in above L8 sphere at high compression
                if (springCompress > 1.1) {
                    var artBlendRaw = Math.min(1, (springCompress - 1.1) / 0.3); // 0→1 over 1.1→1.4
                    var artBlend = artBlendRaw * artBlendRaw * (3 - 2 * artBlendRaw);
                    springArtOverlay.style.left = (window.innerWidth * 0.5) + 'px';
                    springArtOverlay.style.top = (window.innerHeight * 0.1) + 'px';
                    springArtOverlay.style.opacity = artBlend;
                } else {
                    var curOp = parseFloat(springArtOverlay.style.opacity || 0);
                    springArtOverlay.style.opacity = Math.max(0, curOp * 0.88);
                }

                // Spring egg: white dot → egg emoji from L14 center
                if (springEggActive) {
                    // 0→1 over springCompress 1.45→1.9
                    var eggBlend = Math.min(1, (springCompress - 1.95) / 0.05);
                    var eggSmooth = eggBlend * eggBlend * (3 - 2 * eggBlend);
                    // Project L14 mesh position to screen
                    var l14m = shellMeshes[activeLayers.length - 1];
                    var eggPos = new THREE.Vector3().copy(l14m.position);
                    eggPos.project(camera);
                    var eggX = (eggPos.x * 0.5 + 0.5) * window.innerWidth;
                    var eggY = (-eggPos.y * 0.5 + 0.5) * window.innerHeight;
                    springEggEl.style.left = eggX + 'px';
                    springEggEl.style.top = eggY + 'px';
                    // Start as tiny white dot (0.2rem), grow to small egg (1.6rem max)
                    var eggSize = 0.2 + eggSmooth * 2.68;
                    springEggEl.style.fontSize = eggSize + 'rem';
                    springEggEl.style.opacity = 0.3 + eggSmooth * 0.7;
                    springEggEl.style.transform = 'translate(-50%, -50%) scale(' + (0.15 + eggSmooth * 0.85) + ')';
                    // Early phase: white dot via brightness boost; red shadows grow with egg
                    var dotPhase = Math.max(0, 1 - eggBlend * 3);
                    var glowShadowSize = Math.round(10 + eggSmooth * 40);
                    var glowOuterSize = Math.round(20 + eggSmooth * 80);
                    springEggEl.style.filter = 'drop-shadow(0 0 ' + glowShadowSize + 'px rgba(255,255,255,' + (0.3 + eggSmooth * 0.5) + ')) drop-shadow(0 0 ' + glowOuterSize + 'px rgba(220,230,255,' + (0.15 + eggSmooth * 0.4) + ')) brightness(' + (1 + dotPhase * 8) + ')';
                    springEggEl.style.pointerEvents = 'auto';
                    springEggEl.style.cursor = 'pointer';
                } else {
                    springEggEl.style.pointerEvents = 'none';
                    springEggEl.style.cursor = '';
                    var eggCurOp = parseFloat(springEggEl.style.opacity || 0);
                    if (eggCurOp > 0.01) {
                        springEggEl.style.opacity = Math.max(0, eggCurOp * 0.85);
                        var eggCurSize = parseFloat(springEggEl.style.fontSize || 0);
                        springEggEl.style.fontSize = Math.max(0, eggCurSize * 0.85) + 'rem';
                        springEggEl.style.transform = 'translate(-50%, -50%) scale(' + (eggCurOp * 0.85) + ')';
                    }
                }

                // Camera: pull back when a layer is pulled out, L8 extra dramatic
                var l8CameraZoom = 0;
                var isGWActive = activeLayerIndex >= 0 && activeLayers[activeLayerIndex] && activeLayers[activeLayerIndex].zone === 'gateway';
                if (isGWActive) {
                    l8CameraZoom = 1.0; // pull back farther to show the drama
                }
                var pullOutCamOffset = (activeLayerIndex >= 0) ? ((isGWActive ? 2.5 : 1.5) * Math.min(1, Math.max(0, (rawMorph - 0.15) / 0.35))) : 0;
                var targetCamY = 5.0 + mp * (-4.5);
                var targetCamZ = 7 + mp * 1 + l8CameraZoom + pullOutCamOffset;
                // Tunnel: reposition camera to view the slinky
                if (tunnelProgress.value > 0.01) {
                    var tt = tunnelProgress.value;
                    targetCamY += (1.0 - targetCamY) * tt;
                    targetCamZ += (10 - targetCamZ) * tt;
                }
                var camLerp = (t < 0.5) ? 1.0 : 0.03; // snap on first frame
                camera.position.y += (targetCamY - camera.position.y) * camLerp;
                camera.position.z += (targetCamZ - camera.position.z) * camLerp;

                // Apply closing shrink to NI overlay (scale block is above, before NI projection)
                var shrinkValNI = closingShrink.value;
                var closingShrinkScaleNI = 1 - shrinkValNI * 0.6;
                if (niOpacity > 0.01 && shrinkValNI > 0.01) {
                    niOverlay.style.transform = 'translate(0, -50%) scale(' + closingShrinkScaleNI + ')';
                    niOverlay.style.transformOrigin = 'left center';
                } else if (niOpacity > 0.01) {
                    niOverlay.style.transform = 'translate(0, -50%)';
                    niOverlay.style.transformOrigin = 'left center';
                }

                // Sync brain position to L8's actual mesh position (follows spring compression)
                if (gwIdxGlobal >= 0 && gwIdxGlobal < shellMeshes.length) {
                    var l8Mesh = shellMeshes[gwIdxGlobal];
                    coreMesh.position.y = l8Mesh.position.y;
                    glowMesh.position.y = l8Mesh.position.y;
                    nodeCloud.position.y = l8Mesh.position.y;
                    if (synapseLines) synapseLines.position.y = l8Mesh.position.y;
                }

                // (Wireframe overlays removed)

                // Gateway light — extra flamboyant when L8 is active
                var gwLightBase = 0.8;
                var gwLightPulse = Math.sin(t*3.0)*0.4;
                var gwActive = activeLayerIndex >= 0 && activeLayers[activeLayerIndex] && activeLayers[activeLayerIndex].zone === 'gateway';
                if (gwActive) {
                    gwLightBase = 3.5;
                    gwLightPulse = Math.sin(t*6.0)*1.2 + Math.sin(t*9.5)*0.5; // fast double-pulse
                }
                gatewayLight.intensity += ((gwLightBase + gwLightPulse) - gatewayLight.intensity) * (gwActive ? 0.12 : 0.05);

                // Dust drift
                dustCloud.rotation.y = t*0.02;
                dustCloud.rotation.x = Math.sin(t*0.1)*0.05;

                renderer.render(scene, camera);
            }
            animate();
        }

        // (2D fallback canvas removed — framework is now scroll-driven 3D only)

        // =============================================
        // BRAND.JSON LOADER
        // =============================================
        fetch('https://raw.githubusercontent.com/qinnovates/mindloft/main/neurosecurity/legacy-core/resources/brand/brand.json')
            .then(function(r) { return r.json(); })
            .catch(function() { return null; })
            .then(function(data) {
                if (!data || !data.oni) return;
                // Update page title meta if needed
                var desc = document.querySelector('meta[name="description"]');
                if (desc && data.oni.description) {
                    desc.content = data.oni.description;
                }
            });

    })();
    </script>
</body>
</html>
