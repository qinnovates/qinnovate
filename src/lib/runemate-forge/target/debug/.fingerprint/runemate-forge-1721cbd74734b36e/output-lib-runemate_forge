{"$message_type":"diagnostic","message":"unused import: `crate::error::ForgeError`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":81,"byte_end":105,"line_start":7,"line_end":7,"column_start":5,"column_end":29,"is_primary":true,"text":[{"text":"use crate::error::ForgeError;","highlight_start":5,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":77,"byte_end":107,"line_start":7,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use crate::error::ForgeError;","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `crate::error::ForgeError`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:7:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use crate::error::ForgeError;\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `f32: std::cmp::Eq` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/ast.rs","byte_start":1425,"byte_end":1428,"line_start":67,"line_end":67,"column_start":13,"column_end":16,"is_primary":true,"text":[{"text":"    Percent(f32),","highlight_start":13,"highlight_end":16}],"label":"the trait `std::cmp::Eq` is not implemented for `f32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/ast.rs","byte_start":1355,"byte_end":1357,"line_start":63,"line_end":63,"column_start":52,"column_end":54,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Hash, Clone)]","highlight_start":52,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Eq)]","def_site_span":{"file_name":"/rustc/01f6ddf7588f42ae2d7eb0a2f21d44e8e96674cf/library/core/src/cmp.rs","byte_start":13141,"byte_end":13153,"line_start":356,"line_end":356,"column_start":1,"column_end":13,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the following other types implement trait `std::cmp::Eq`:\n  i128\n  i16\n  i32\n  i64\n  i8\n  isize\n  u128\n  u16\nand 4 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `AssertParamIsEq`","code":null,"level":"note","spans":[{"file_name":"/rustc/01f6ddf7588f42ae2d7eb0a2f21d44e8e96674cf/library/core/src/cmp.rs","byte_start":13514,"byte_end":13562,"line_start":367,"line_end":367,"column_start":1,"column_end":49,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `f32: std::cmp::Eq` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/ast.rs:67:13\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Hash, Clone)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                    \u001b[1m\u001b[94m--\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m67\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Percent(f32),\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `std::cmp::Eq` is not implemented for `f32`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `std::cmp::Eq`:\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n             u128\n             u16\n           and 4 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `AssertParamIsEq`\n  \u001b[1m\u001b[94m--> \u001b[0m/rustc/01f6ddf7588f42ae2d7eb0a2f21d44e8e96674cf/library/core/src/cmp.rs:367:1\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `f32: Hash` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/ast.rs","byte_start":1425,"byte_end":1428,"line_start":67,"line_end":67,"column_start":13,"column_end":16,"is_primary":true,"text":[{"text":"    Percent(f32),","highlight_start":13,"highlight_end":16}],"label":"the trait `Hash` is not implemented for `f32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/ast.rs","byte_start":1359,"byte_end":1363,"line_start":63,"line_end":63,"column_start":56,"column_end":60,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Hash, Clone)]","highlight_start":56,"highlight_end":60}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Hash)]","def_site_span":{"file_name":"/rustc/01f6ddf7588f42ae2d7eb0a2f21d44e8e96674cf/library/core/src/hash/mod.rs","byte_start":7913,"byte_end":7927,"line_start":251,"line_end":251,"column_start":5,"column_end":19,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the following other types implement trait `Hash`:\n  i128\n  i16\n  i32\n  i64\n  i8\n  isize\n  u128\n  u16\nand 4 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `f32: Hash` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/ast.rs:67:13\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Hash, Clone)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                        \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m67\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Percent(f32),\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Hash` is not implemented for `f32`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Hash`:\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n             u128\n             u16\n           and 4 others\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `f32: Hash` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/ast.rs","byte_start":1438,"byte_end":1441,"line_start":68,"line_end":68,"column_start":8,"column_end":11,"is_primary":true,"text":[{"text":"    Vh(f32),","highlight_start":8,"highlight_end":11}],"label":"the trait `Hash` is not implemented for `f32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/ast.rs","byte_start":1359,"byte_end":1363,"line_start":63,"line_end":63,"column_start":56,"column_end":60,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Hash, Clone)]","highlight_start":56,"highlight_end":60}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Hash)]","def_site_span":{"file_name":"/rustc/01f6ddf7588f42ae2d7eb0a2f21d44e8e96674cf/library/core/src/hash/mod.rs","byte_start":7913,"byte_end":7927,"line_start":251,"line_end":251,"column_start":5,"column_end":19,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the following other types implement trait `Hash`:\n  i128\n  i16\n  i32\n  i64\n  i8\n  isize\n  u128\n  u16\nand 4 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `f32: Hash` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/ast.rs:68:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Hash, Clone)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                        \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m68\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Vh(f32),\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Hash` is not implemented for `f32`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Hash`:\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n             u128\n             u16\n           and 4 others\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `f32: Hash` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/ast.rs","byte_start":1451,"byte_end":1454,"line_start":69,"line_end":69,"column_start":8,"column_end":11,"is_primary":true,"text":[{"text":"    Vw(f32),","highlight_start":8,"highlight_end":11}],"label":"the trait `Hash` is not implemented for `f32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/ast.rs","byte_start":1359,"byte_end":1363,"line_start":63,"line_end":63,"column_start":56,"column_end":60,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Hash, Clone)]","highlight_start":56,"highlight_end":60}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Hash)]","def_site_span":{"file_name":"/rustc/01f6ddf7588f42ae2d7eb0a2f21d44e8e96674cf/library/core/src/hash/mod.rs","byte_start":7913,"byte_end":7927,"line_start":251,"line_end":251,"column_start":5,"column_end":19,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the following other types implement trait `Hash`:\n  i128\n  i16\n  i32\n  i64\n  i8\n  isize\n  u128\n  u16\nand 4 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `f32: Hash` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/ast.rs:69:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Hash, Clone)]\n   \u001b[1m\u001b[94m|\u001b[0m                                                        \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m69\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Vw(f32),\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Hash` is not implemented for `f32`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Hash`:\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n             u128\n             u16\n           and 4 others\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `RcDom: TreeSink` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lexer.rs","byte_start":360,"byte_end":376,"line_start":12,"line_end":12,"column_start":30,"column_end":46,"is_primary":true,"text":[{"text":"    let dom = parse_document(RcDom::default(), opts)","highlight_start":30,"highlight_end":46}],"label":"the trait `TreeSink` is not implemented for `RcDom`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lexer.rs","byte_start":345,"byte_end":359,"line_start":12,"line_end":12,"column_start":15,"column_end":29,"is_primary":false,"text":[{"text":"    let dom = parse_document(RcDom::default(), opts)","highlight_start":15,"highlight_end":29}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `markup5ever` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/mac/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/markup5ever-0.14.1/interface/tree_builder.rs","byte_start":4199,"byte_end":4217,"line_start":120,"line_end":120,"column_start":1,"column_end":19,"is_primary":true,"text":[{"text":"pub trait TreeSink {","highlight_start":1,"highlight_end":19}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/mac/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/markup5ever-0.11.0/interface/tree_builder.rs","byte_start":3834,"byte_end":3852,"line_start":106,"line_end":106,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"pub trait TreeSink {","highlight_start":1,"highlight_end":19}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `parse_document`","code":null,"level":"note","spans":[{"file_name":"/Users/mac/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/html5ever-0.29.1/src/driver.rs","byte_start":1323,"byte_end":1337,"line_start":40,"line_end":40,"column_start":8,"column_end":22,"is_primary":false,"text":[{"text":"pub fn parse_document<Sink>(sink: Sink, opts: ParseOpts) -> Parser<Sink>","highlight_start":8,"highlight_end":22}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/mac/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/html5ever-0.29.1/src/driver.rs","byte_start":1405,"byte_end":1413,"line_start":42,"line_end":42,"column_start":11,"column_end":19,"is_primary":true,"text":[{"text":"    Sink: TreeSink,","highlight_start":11,"highlight_end":19}],"label":"required by this bound in `parse_document`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `RcDom: TreeSink` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lexer.rs:12:30\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m12\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let dom = parse_document(RcDom::default(), opts)\n    \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[94m--------------\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `TreeSink` is not implemented for `RcDom`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `markup5ever` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/mac/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/markup5ever-0.14.1/interface/tree_builder.rs:120:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m120\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait TreeSink {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/mac/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/markup5ever-0.11.0/interface/tree_builder.rs:106:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m106\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait TreeSink {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `parse_document`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/mac/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/html5ever-0.29.1/src/driver.rs:42:11\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m40\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn parse_document<Sink>(sink: Sink, opts: ParseOpts) -> Parser<Sink>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n \u001b[1m\u001b[94m41\u001b[0m \u001b[1m\u001b[94m|\u001b[0m where\n \u001b[1m\u001b[94m42\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Sink: TreeSink,\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[92m^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `parse_document`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `from_utf8` exists for struct `Parser<RcDom>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lexer.rs","byte_start":345,"byte_end":393,"line_start":12,"line_end":13,"column_start":15,"column_end":10,"is_primary":false,"text":[{"text":"    let dom = parse_document(RcDom::default(), opts)","highlight_start":15,"highlight_end":53},{"text":"        .from_utf8()","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lexer.rs","byte_start":393,"byte_end":402,"line_start":13,"line_end":13,"column_start":10,"column_end":19,"is_primary":true,"text":[{"text":"        .from_utf8()","highlight_start":10,"highlight_end":19}],"label":"method cannot be called on `Parser<RcDom>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/mac/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/markup5ever_rcdom-0.2.0/lib.rs","byte_start":6346,"byte_end":6362,"line_start":205,"line_end":205,"column_start":1,"column_end":17,"is_primary":false,"text":[{"text":"pub struct RcDom {","highlight_start":1,"highlight_end":17}],"label":"doesn't satisfy `RcDom: TreeSink`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`RcDom: TreeSink`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `from_utf8` exists for struct `Parser<RcDom>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lexer.rs:13:10\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m12\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let dom = parse_document(RcDom::default(), opts)\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m _______________-\u001b[0m\n \u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .from_utf8()\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `Parser<RcDom>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_________|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/mac/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/markup5ever_rcdom-0.2.0/lib.rs:205:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m205\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct RcDom {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m----------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `RcDom: TreeSink`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `RcDom: TreeSink`\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `RcDom: TreeSink` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lexer.rs","byte_start":345,"byte_end":383,"line_start":12,"line_end":12,"column_start":15,"column_end":53,"is_primary":true,"text":[{"text":"    let dom = parse_document(RcDom::default(), opts)","highlight_start":15,"highlight_end":53}],"label":"the trait `TreeSink` is not implemented for `RcDom`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `markup5ever` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/mac/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/markup5ever-0.14.1/interface/tree_builder.rs","byte_start":4199,"byte_end":4217,"line_start":120,"line_end":120,"column_start":1,"column_end":19,"is_primary":true,"text":[{"text":"pub trait TreeSink {","highlight_start":1,"highlight_end":19}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/mac/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/markup5ever-0.11.0/interface/tree_builder.rs","byte_start":3834,"byte_end":3852,"line_start":106,"line_end":106,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"pub trait TreeSink {","highlight_start":1,"highlight_end":19}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `Parser`","code":null,"level":"note","spans":[{"file_name":"/Users/mac/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/html5ever-0.29.1/src/driver.rs","byte_start":2964,"byte_end":2970,"line_start":97,"line_end":97,"column_start":12,"column_end":18,"is_primary":false,"text":[{"text":"pub struct Parser<Sink>","highlight_start":12,"highlight_end":18}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/mac/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/html5ever-0.29.1/src/driver.rs","byte_start":2993,"byte_end":3001,"line_start":99,"line_end":99,"column_start":11,"column_end":19,"is_primary":true,"text":[{"text":"    Sink: TreeSink,","highlight_start":11,"highlight_end":19}],"label":"required by this bound in `Parser`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `RcDom: TreeSink` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lexer.rs:12:15\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m12\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let dom = parse_document(RcDom::default(), opts)\n    \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `TreeSink` is not implemented for `RcDom`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `markup5ever` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/mac/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/markup5ever-0.14.1/interface/tree_builder.rs:120:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m120\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait TreeSink {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/mac/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/markup5ever-0.11.0/interface/tree_builder.rs:106:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m106\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait TreeSink {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `Parser`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/mac/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/html5ever-0.29.1/src/driver.rs:99:11\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m97\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Parser<Sink>\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this struct\u001b[0m\n \u001b[1m\u001b[94m98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m where\n \u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Sink: TreeSink,\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[92m^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Parser`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/lexer.rs","byte_start":490,"byte_end":491,"line_start":15,"line_end":15,"column_start":45,"column_end":46,"is_primary":false,"text":[{"text":"        .map_err(|e| ForgeError::ParseError(e.to_string()))?;","highlight_start":45,"highlight_end":46}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lexer.rs","byte_start":464,"byte_end":465,"line_start":15,"line_end":15,"column_start":19,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| ForgeError::ParseError(e.to_string()))?;","highlight_start":19,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/lexer.rs","byte_start":465,"byte_end":465,"line_start":15,"line_end":15,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| ForgeError::ParseError(e.to_string()))?;","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lexer.rs:15:19\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .map_err(|e| ForgeError::ParseError(e.to_string()))?;\n   \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[91m^\u001b[0m                         \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        .map_err(|e\u001b[92m: /* Type */\u001b[0m| ForgeError::ParseError(e.to_string()))?;\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 8 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 8 previous errors; 1 warning emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0277, E0282, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0277, E0282, E0599.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
