"""
Motor Cortex & BCI Neural Decoding
Generated by LearnViz

Visualizes how brain-computer interfaces decode motor intent from M1.
"""
from manim import *
import numpy as np


class TextManager:
    """Manages text display to prevent overlaps."""

    def __init__(self, scene):
        self.scene = scene
        self.active_texts = {}
        self.regions = {
            "title": UP * 3.5,
            "top": UP * 3.0,
            "bottom": DOWN * 3.3,
            "center": ORIGIN,
        }

    def show(self, text: str, region: str = "bottom", font_size: int = 22,
             color=WHITE, duration: float = 0.5) -> Text:
        if region in self.active_texts:
            self.scene.play(FadeOut(self.active_texts[region]), run_time=0.2)
        text_obj = Text(text, font_size=font_size, color=color)
        text_obj.move_to(self.regions.get(region, ORIGIN))
        if text_obj.width > 13:
            text_obj.scale(13 / text_obj.width)
        self.scene.play(Write(text_obj), run_time=duration)
        self.active_texts[region] = text_obj
        return text_obj

    def clear(self, region: str = None):
        if region and region in self.active_texts:
            self.scene.play(FadeOut(self.active_texts[region]), run_time=0.2)
            del self.active_texts[region]
        elif region is None and self.active_texts:
            self.scene.play(*[FadeOut(t) for t in self.active_texts.values()], run_time=0.3)
            self.active_texts.clear()


class MotorCortexBCIScene(Scene):
    def construct(self):
        self.tm = TextManager(self)

        self.show_intro()
        self.show_brain_overview()
        self.show_electrode_array()
        self.show_neural_signals()
        self.show_population_coding()
        self.show_bci_decoding()
        self.show_conclusion()
        self.wait(2)

    def show_intro(self):
        title = Text("Motor Cortex & BCI Decoding", font_size=44)
        subtitle = Text("How BCIs read your motor intentions", font_size=24, color=GRAY)
        subtitle.next_to(title, DOWN, buff=0.3)

        self.play(Write(title))
        self.play(FadeIn(subtitle))
        self.wait(1)

        intro = Text(
            "Brain-Computer Interfaces decode movement intent\n"
            "from the primary motor cortex (M1)",
            font_size=20, color=BLUE_B
        )
        intro.next_to(subtitle, DOWN, buff=0.5)
        self.play(FadeIn(intro))
        self.wait(2)
        self.play(FadeOut(title), FadeOut(subtitle), FadeOut(intro))

    def show_brain_overview(self):
        self.tm.show("The motor cortex (M1) controls voluntary movement", region="bottom", color=BLUE_B)

        # Simplified brain outline
        brain = Ellipse(width=5, height=4, color=PINK, fill_opacity=0.3, stroke_width=2)
        brain.shift(LEFT * 2)

        # Motor cortex region (precentral gyrus)
        m1 = Arc(radius=1.8, start_angle=PI/3, angle=PI/3, color=RED, stroke_width=6)
        m1.shift(LEFT * 2 + UP * 0.3)
        m1_label = Text("M1 (Motor Cortex)", font_size=16, color=RED)
        m1_label.next_to(m1, UP, buff=0.2)

        self.play(Create(brain))
        self.play(Create(m1), Write(m1_label))

        # Motor homunculus representation
        self.tm.show("M1 has a 'motor map' - different areas control different body parts", region="bottom")

        homunculus = VGroup()
        parts = [("Leg", UP*0.8), ("Arm", UP*0.3+RIGHT*0.3), ("Hand", DOWN*0.1+RIGHT*0.5), ("Face", DOWN*0.6+RIGHT*0.7)]
        for name, offset in parts:
            dot = Dot(m1.get_center() + offset, color=YELLOW, radius=0.1)
            label = Text(name, font_size=12, color=YELLOW)
            label.next_to(dot, RIGHT, buff=0.1)
            homunculus.add(VGroup(dot, label))

        self.play(Create(homunculus))
        self.wait(2)

        self.brain = brain
        self.m1 = m1
        self.homunculus = homunculus

    def show_electrode_array(self):
        self.tm.show("BCIs use electrode arrays implanted in M1 to record neural signals", region="bottom", color=ORANGE)

        # Utah array representation
        array = VGroup()
        array_bg = Square(side_length=1.2, fill_opacity=0.8, fill_color=DARK_GRAY, stroke_color=WHITE)

        # 10x10 electrode grid
        for i in range(10):
            for j in range(10):
                electrode = Dot(radius=0.03, color=GOLD)
                electrode.move_to(array_bg.get_center() + LEFT*0.5 + DOWN*0.5 + RIGHT*i*0.11 + UP*j*0.11)
                array.add(electrode)

        array.add(array_bg)
        array.move_to(self.m1.get_center())

        array_label = Text("Utah Array\n(96 electrodes)", font_size=14, color=GOLD)
        array_label.next_to(array, RIGHT, buff=0.3)

        # Zoom effect
        self.play(
            self.brain.animate.set_opacity(0.2),
            self.homunculus.animate.set_opacity(0.3),
        )
        self.play(Create(array), Write(array_label))
        self.wait(1.5)

        self.array = array
        self.array_label = array_label

    def show_neural_signals(self):
        self.tm.show("Each electrode records 'spikes' - electrical signals from nearby neurons", region="bottom", color=GREEN)

        # Move array to left side
        self.play(
            FadeOut(self.brain), FadeOut(self.m1), FadeOut(self.homunculus),
            self.array.animate.move_to(LEFT * 4),
            self.array_label.animate.next_to(LEFT * 4, DOWN, buff=0.3)
        )

        # Signal traces
        signals = VGroup()
        axes_group = VGroup()

        for i in range(4):
            # Mini axes for each channel
            ax = Axes(x_range=[0, 2, 1], y_range=[-1, 1, 1], x_length=3, y_length=0.8,
                     axis_config={"include_tip": False, "stroke_width": 1})
            ax.move_to(RIGHT * 1 + UP * (1.5 - i))

            # Random spikes
            np.random.seed(i + 42)
            spike_times = np.random.uniform(0, 2, np.random.randint(3, 8))

            def make_spike_func(times):
                def f(t):
                    val = 0
                    for st in times:
                        if abs(t - st) < 0.05:
                            val += np.exp(-((t - st) / 0.02) ** 2)
                    return val * 0.8
                return f

            trace = ax.plot(make_spike_func(spike_times), color=GREEN, stroke_width=2)

            ch_label = Text(f"Ch {i+1}", font_size=12, color=GRAY)
            ch_label.next_to(ax, LEFT, buff=0.1)

            signals.add(trace)
            axes_group.add(VGroup(ax, ch_label))

        self.play(Create(axes_group))
        self.play(Create(signals), run_time=2)

        self.tm.show("Each spike represents a neuron firing - encoding movement information", region="bottom")
        self.wait(2)

        self.signals = signals
        self.axes_group = axes_group

    def show_population_coding(self):
        self.tm.show("Neurons encode movement DIRECTION using 'population coding'", region="bottom", color=YELLOW)

        # Clear previous
        self.play(FadeOut(self.array), FadeOut(self.array_label),
                 FadeOut(self.signals), FadeOut(self.axes_group))

        # Population vector diagram
        center = ORIGIN

        # Individual neuron preferred directions
        neurons = VGroup()
        vectors = VGroup()
        n_neurons = 8

        for i in range(n_neurons):
            angle = i * 2 * PI / n_neurons
            direction = np.array([np.cos(angle), np.sin(angle), 0])

            # Neuron dot
            neuron = Dot(center + direction * 2.5, color=BLUE, radius=0.15)
            neurons.add(neuron)

            # Contribution vector (varies by neuron)
            weight = 0.3 + 0.7 * max(0, np.cos(angle - PI/4))  # Stronger for upper-right
            vec = Arrow(center, center + direction * weight * 1.5, color=BLUE_B, stroke_width=2, buff=0)
            vectors.add(vec)

        # Population vector (sum)
        pop_vec = Arrow(center, center + np.array([1.2, 1.2, 0]), color=RED, stroke_width=4, buff=0)
        pop_label = Text("Population\nVector", font_size=14, color=RED)
        pop_label.next_to(pop_vec.get_end(), UR, buff=0.1)

        self.play(Create(neurons))
        self.tm.show("Each neuron has a 'preferred direction' - it fires most for that movement", region="bottom")
        self.wait(1)

        self.play(Create(vectors))
        self.tm.show("Neuron firing rates combine to form a 'population vector'", region="bottom")
        self.wait(1)

        self.play(Create(pop_vec), Write(pop_label))
        self.tm.show("The population vector points in the intended movement direction!", region="bottom", color=RED)
        self.wait(2)

        self.neurons = neurons
        self.vectors = vectors
        self.pop_vec = pop_vec
        self.pop_label = pop_label

    def show_bci_decoding(self):
        self.tm.show("BCIs decode this population vector to control devices", region="bottom", color=GREEN)

        # Transition
        self.play(
            self.neurons.animate.shift(LEFT * 3).scale(0.6),
            self.vectors.animate.shift(LEFT * 3).scale(0.6),
            self.pop_vec.animate.shift(LEFT * 3).scale(0.6),
            self.pop_label.animate.shift(LEFT * 3).scale(0.6),
        )

        # Arrow to decoded output
        decode_arrow = Arrow(LEFT * 1, RIGHT * 1, color=WHITE, stroke_width=3)
        decode_label = Text("Decode", font_size=16)
        decode_label.next_to(decode_arrow, UP, buff=0.1)

        self.play(Create(decode_arrow), Write(decode_label))

        # Output: cursor movement
        cursor = Dot(RIGHT * 3, color=GREEN, radius=0.2)
        cursor_label = Text("Cursor", font_size=14, color=GREEN)
        cursor_label.next_to(cursor, DOWN, buff=0.2)

        screen = Rectangle(width=3, height=2, stroke_color=WHITE, fill_opacity=0.1)
        screen.move_to(RIGHT * 3)

        self.play(Create(screen), Create(cursor), Write(cursor_label))

        # Animate cursor moving in decoded direction
        self.play(cursor.animate.shift(UR * 0.5), run_time=0.5)
        self.play(cursor.animate.shift(UR * 0.3), run_time=0.3)

        self.tm.show("Patient thinks 'move right' → M1 neurons fire → BCI decodes → cursor moves!", region="bottom", color=GREEN)
        self.wait(2)

    def show_conclusion(self):
        self.tm.clear()

        # Summary
        summary = VGroup(
            Text("BCI Neural Decoding Summary", font_size=24, color=WHITE),
            Text("1. Electrodes record spikes from M1 neurons", font_size=18, color=GOLD),
            Text("2. Each neuron has a preferred movement direction", font_size=18, color=BLUE),
            Text("3. Population coding combines all neurons", font_size=18, color=YELLOW),
            Text("4. Decoder translates to device commands", font_size=18, color=GREEN),
        ).arrange(DOWN, aligned_edge=LEFT, buff=0.25)

        box = SurroundingRectangle(summary, color=WHITE, buff=0.3, corner_radius=0.1)
        summary_group = VGroup(box, summary)
        summary_group.move_to(ORIGIN)

        self.play(FadeOut(*self.mobjects))
        self.play(Create(box), Write(summary), run_time=2)

        final = Text("This is how paralyzed patients control robotic arms with thought!", font_size=18, color=BLUE_B)
        final.next_to(summary_group, DOWN, buff=0.5)
        self.play(FadeIn(final))


if __name__ == "__main__":
    pass
